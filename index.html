<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Werwolf Deluxe - Spielleiter App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a; /* Dunkler Hintergrund */
            color: #e0e0e0; /* Heller Text */
        }
        .screen {
            display: none; /* Alle Screens standardm√§√üig ausblenden */
            padding: 2rem;
            border: 1px solid #444;
            border-radius: 8px;
            background-color: #2a2a2a; /* Etwas hellerer Hintergrund f√ºr Screens */
            margin-top: 1rem;
            min-height: 450px; /* Etwas h√∂her f√ºr mehr Inhalt */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .screen.active {
            display: flex; /* Aktiven Screen anzeigen */
        }
        button, input[type="text"], select {
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            border: 1px solid #555; /* Leichter Rand f√ºr bessere Sichtbarkeit */
            margin: 0.5rem 0.5rem 0.5rem 0;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
            background-color: #4a5568; /* Standard Grau f√ºr Inputs/Selects */
            color: #e0e0e0;
        }
        button {
            background-color: #5a67d8; /* Indigo */
            color: white;
            border: none;
        }
        button:hover:not(:disabled) {
            background-color: #434190;
        }
        button:disabled {
            background-color: #3a3a3a;
            color: #777;
            cursor: not-allowed;
        }
        button.secondary {
            background-color: #4a5568; /* Grau */
        }
        button.secondary:hover:not(:disabled) {
            background-color: #2d3748;
        }
        button.danger {
            background-color: #e53e3e; /* Rot */
        }
        button.danger:hover:not(:disabled) {
            background-color: #c53030;
        }
        input[type="text"], select {
            background-color: #3a3a3a; /* Dunkleres Grau f√ºr Inputs/Selects */
        }
        select {
             appearance: none; /* Standard-Pfeil entfernen */
             background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23BBB%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.6-3.6%205.4-7.9%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
             background-repeat: no-repeat;
             background-position: right 0.7rem top 50%;
             background-size: 0.65rem auto;
             padding-right: 2.5rem; /* Platz f√ºr den Pfeil */
        }
        h1, h2, h3 {
            color: #ffffff;
            margin-bottom: 1rem;
        }
        ul {
            list-style: none;
            padding: 0;
            margin: 0; /* Standard-Margin entfernen */
        }
        li {
            background-color: #3a3a3a;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; /* Erlaubt Umbruch bei kleinen Bildschirmen */
        }
        .player-info {
            flex-grow: 1;
            margin-right: 1rem; /* Abstand zu den Buttons */
        }
        .player-actions {
            flex-shrink: 0; /* Verhindert, dass Buttons schrumpfen */
        }
        .player-actions button, .player-actions select {
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }
        .role-info {
            font-size: 0.9em;
            color: #a0aec0;
            display: block; /* Sorgt f√ºr Zeilenumbruch unter dem Namen */
        }
        .status-alive { color: #68d391; } /* Gr√ºn */
        .status-dead { color: #fc8181; text-decoration: line-through; opacity: 0.6; } /* Rot und durchgestrichen */
        .selected {
            outline: 2px solid #63b3ed; /* Blauer Rand f√ºr Auswahl */
            outline-offset: 2px;
        }
        .icon { display: inline-block; margin-left: 5px; font-size: 0.9em; }
        .icon-heart { color: #e53e3e; } /* Rot */
        .icon-shield { color: #63b3ed; } /* Blau */
        .icon-skull { color: #a0aec0; } /* Grau */
        .icon-potion { color: #9f7aea; } /* Lila */
        .icon-eye { color: #4fd1c5; } /* T√ºrkis */
        .icon-question { color: #f6e05e; } /* Gelb */
        .icon-moon { color: #f6e05e; } /* Gelb */
        .icon-sun { color: #f6ad55; } /* Orange */
        .icon-poison { color: #48bb78; } /* Gr√ºn f√ºr Gift */
        .icon-cross { color: #e53e3e; } /* Rot f√ºr Blockade/Tod */
        .icon-hand { color: #ed8936; } /* Orange f√ºr Fisterin */
        .icon-wand { color: #d53f8c; } /* Pink f√ºr Magie */
        .icon-mask { color: #a0aec0; } /* Grau f√ºr Travestie */
        .icon-tools { color: #a0aec0; } /* Grau f√ºr Dielenschleiferin */
        .icon-megaphone { color: #f6e05e; } /* Gelb f√ºr K√§the */
        .icon-zombie { color: #9f7aea; } /* Lila f√ºr Nekromant */
        .icon-first-aid { color: #68d391; } /* Gr√ºn f√ºr Brunhilde */
        .icon-magnifying-glass { color: #4fd1c5; } /* T√ºrkis f√ºr Suche */
        .icon-warning { color: #f56565; } /* Rot f√ºr Warnung/Fehler */

        .hidden { display: none; }
        .error-message { color: #f56565; font-size: 0.9em; margin-top: 5px; }
        .player-list-container { max-height: 300px; overflow-y: auto; margin-bottom: 1rem; } /* Scrollbarer Bereich */
    </style>
</head>
<body class="p-4 md:p-8">

    <h1 class="text-3xl font-bold text-center mb-6">Werwolf Deluxe - Spielleiter App</h1>

    <div id="screen-setup-players" class="screen active">
        <div>
            <h2 class="text-2xl mb-4">Spiel einrichten: Spieleranzahl</h2>
            <p class="mb-4">Wie viele Spieler ziehen in unser kleines charmantes Dorf?</p>
            <div id="player-count-buttons" class="flex flex-wrap gap-2">
                </div>
        </div>
        <div>
            <p class="text-sm text-gray-400 mt-4">W√§hle die Anzahl der Spieler (8-15).</p>
        </div>
    </div>

    <div id="screen-setup-names" class="screen">
        <div>
            <h2 class="text-2xl mb-4">Spieler benennen</h2>
            <p class="mb-4">Bitte gib die Namen der Spieler ein:</p>
            <div id="player-name-inputs" class="space-y-2 player-list-container">
                </div>
        </div>
        <div>
            <button id="btn-go-to-role-assignment">Weiter zur Rollenverteilung</button>
        </div>
    </div>

    <div id="screen-setup-roles" class="screen">
        <div>
            <h2 class="text-2xl mb-4">Rollen verteilen</h2>
            <p class="mb-4">Bitte weise jedem Spieler seine gezogene Rolle zu:</p>
            <div id="player-role-assignment" class="space-y-2 player-list-container">
                </div>
            <p id="role-assignment-error" class="error-message hidden"></p>
        </div>
        <div>
             <p class="text-sm text-gray-400 mb-2">Stelle sicher, dass die Anzahl der Werw√∂lfe stimmt und keine inkompatiblen Rollen gew√§hlt wurden.</p>
            <button id="btn-start-game">Spiel starten</button>
        </div>
    </div>

    <div id="screen-night" class="screen">
        <div>
            <h2 class="text-2xl mb-4"><span class="icon icon-moon">üåô</span> Nacht <span id="night-counter">1</span></h2>
            <h3 id="night-role-action" class="text-xl mb-4">Warte auf n√§chste Aktion...</h3>
            <p id="night-instruction" class="mb-4"></p>
            <div id="night-special-ui" class="mb-4 space-y-2">
                </div>
            <p class="mb-2 font-semibold">Spielerliste:</p>
            <ul id="night-player-list" class="player-list-container">
                </ul>
        </div>
        <div>
            <p id="selection-info" class="text-sm text-gray-400 mb-2 h-4"></p> <button id="btn-next-action" class="w-full">Aktion best√§tigen / N√§chster Schritt</button>
        </div>
    </div>

    <div id="screen-day-results" class="screen">
        <div>
            <h2 class="text-2xl mb-4"><span class="icon icon-sun">‚òÄÔ∏è</span> Tag <span id="day-counter">1</span> - Was ist passiert?</h2>
            <p class="mb-4">Die Nacht war unruhig. Folgendes ist geschehen:</p>
            <ul id="day-events-list" class="mb-4 player-list-container">
                </ul>
             <div id="day-event-announcement" class="mb-4 p-3 bg-yellow-900 border border-yellow-700 rounded hidden">
                <h3 class="font-semibold text-yellow-300">Sonderereignis!</h3>
                <p id="day-event-details"></p>
            </div>
            <p class="mb-2 font-semibold">Aktueller Spielerstatus:</p>
            <ul id="day-player-list-status" class="player-list-container">
                </ul>
        </div>
        <div>
             <button id="btn-start-discussion" class="w-full">Diskussion beginnen</button>
        </div>
    </div>

    <div id="screen-day-vote" class="screen">
         <div>
            <h2 class="text-2xl mb-4"><span class="icon icon-sun">‚òÄÔ∏è</span> Tag <span id="day-counter-vote">1</span> - Diskussion & Lynchung</h2>
            <p class="mb-2">Das Dorf diskutiert und stimmt ab, wer gelyncht werden soll.</p>
            <p id="day-vote-timer" class="mb-2 font-semibold text-yellow-400"></p>
            <p id="day-vote-restrictions" class="mb-4 text-orange-400"></p>
            <p class="mb-2 font-semibold">W√§hlt den Spieler aus, der gelyncht werden soll:</p>
            <ul id="day-vote-list" class="player-list-container">
                </ul>
         </div>
         <div>
            <p id="lynch-selection-info" class="text-sm text-gray-400 mb-2 h-4"></p>
            <div id="beatrix-intervention" class="hidden mb-2">
                 <button id="btn-beatrix-intervene" class="secondary">Blutmagierin Beatrix eingreifen lassen?</button>
                 <span id="beatrix-result" class="ml-2"></span>
            </div>
            <button id="btn-confirm-lynch" class="w-full" disabled>Lynchmord best√§tigen</button>
         </div>
    </div>

     <div id="screen-lynch-result" class="screen">
        <div>
            <h2 class="text-2xl mb-4"><span class="icon icon-skull">üíÄ</span> Lynch-Ergebnis</h2>
            <p id="lynch-result-text" class="mb-4 text-xl"></p>
            <p id="lynch-role-reveal" class="mb-4 font-semibold text-lg"></p>
            <div id="lynch-consequences" class="mb-4 text-red-400 space-y-1">
                </div>
             <p class="mb-2 font-semibold">Verbleibende Spieler:</p>
            <ul id="lynch-player-list-status" class="player-list-container">
                </ul>
        </div>
        <div>
            <button id="btn-start-next-night" class="w-full">N√§chste Nacht beginnen</button>
        </div>
    </div>

    <div id="screen-game-over" class="screen">
        <div>
            <h2 class="text-2xl mb-4">Spielende!</h2>
            <p id="game-over-message" class="text-xl font-semibold mb-4"></p>
            <p class="mb-2">Die Gewinner sind:</p>
            <ul id="winners-list" class="mb-4">
                </ul>
        </div>
        <div>
            <button id="btn-new-game" class="w-full">Neues Spiel starten</button>
        </div>
    </div>

    <div id="screen-setup-events" class="screen">
        <div>
            <h2 class="text-2xl mb-4">Sonderereignisse</h2>
            <p class="mb-4">Sollen die zuf√§lligen Tagesereignisse "Unwetter" und "Pandemie" im Spiel vorkommen k√∂nnen?</p>
            <p class="text-sm text-gray-400 mb-4">(Sie k√∂nnen fr√ºhestens ab Tag 3 mit 20% Wahrscheinlichkeit auftreten.)</p>
        </div>
        <div>
            <button id="btn-events-yes">Ja, Ereignisse aktivieren</button>
            <button id="btn-events-no" class="secondary">Nein, ohne Ereignisse spielen</button>
        </div>
    </div>


    <script>
        // --- Globale Variablen und Spielzustand ---
        let gameState = {
            players: [], // { id, name, role, roleKey, roleDetails, status: 'alive'/'dead', isProtected, isPoisoned, poisonTimer, linkedTo: [], clientForDielenschleiferin, misc: {} }
            playerCount: 0,
            currentScreen: 'screen-setup-players',
            night: 0,
            day: 0,
            currentRoleIndex: -1, // Index in der `rolesActingTonight` Liste
            rolesActingTonight: [], // Die Rollen, die in der aktuellen Nacht tats√§chlich agieren
            nightActions: [], // Gespeicherte Aktionen der Nacht
            lynchTarget: null, // Name des Spielers
            gameLog: [],
            usedAbilities: {}, // Z√§hlt Nutzung einmaliger F√§higkeiten, z.B. { 'player-3_retten': 1, 'player-5_protect_neighbor': 1 }
            specialConditions: {
                linkedPlayers: [], // Array von Spieler-IDs
                twinkDeactivated: false,
                bauerFoundBaerbel: false,
                eventsEnabled: false,
                lastEventDay: 0, // Um Abstand zwischen Events zu sichern
                activeEvent: null, // { name: 'Pandemie', affectedPlayers: [id1, id2...] }
            },
            config: {
                werwolfCount: { 8: 2, 9: 2, 10: 3, 11: 3, 12: 3, 13: 4, 14: 4, 15: 4 },
                eventProbability: 0.20, // 20% Chance f√ºr ein Event pro Tag (ab Tag 3)
                minEventDay: 3,
                minDaysBetweenEvents: 2,
                discussionTime: 7 * 60, // 7 Minuten in Sekunden
                unwetterTime: 2 * 60, // 2 Minuten in Sekunden
            }
        };

        // --- Rollendefinitionen (komplett, basierend auf CSV/Doc) ---
        // Schl√ºssel sind eindeutig und werden intern verwendet
        const ROLES = {
            // Dorfbewohner Neutral
            DORFBEWOHNER: { name: 'Dorfbewohner/in', team: 'dorf', nightAction: false },
            DIELENSCHLEIFERIN: { name: 'Dielenschleiferin', team: 'dorf', nightAction: true, actionType: 'choose_client', order: 90 },
            HEIMSCHEISSERIN: { name: 'Heimschei√üerin', team: 'dorf', nightAction: true, actionType: 'observe_passive', order: 11 }, // Passiv w√§hrend WW
            PROKRASTINATIONS_PAULA: { name: 'Prokrastinations Paula', team: 'dorf', nightAction: false, special: 'getsNewRoleOnNight2' },
            SCHUTZSCHILD_SIGRID: { name: 'Schutzschild-Sigrid', team: 'dorf', nightAction: true, actionType: 'protect_neighbor', uses: 1, order: 41 },

            // Dorfbewohner mit F√§higkeiten
            BORDELL_BAERBEL: { name: 'Bordell B√§rbel', team: 'dorf', nightAction: true, actionType: 'protect_guest', order: 40 },
            MANSPLAINING_MARTIN: { name: 'Mansplaining Martin', team: 'dorf', nightAction: true, actionType: 'reveal_role', order: 70, special: 'sabine_interaction' },
            KRAEUTERHEXE_HILDE: { name: 'Kr√§uterhexe Hilde', team: 'dorf', nightAction: true, actionType: 'use_potion', uses: { protect: 1, block_ww: 1, chaos: 1 }, order: 35 },
            NEKROMANT_NORBERT: { name: 'Nekromant Norbert', team: 'dorf', nightAction: true, actionType: 'ask_dead', uses: 1, order: 75, condition: 'player_is_dead' },
            BOY_BUTTER_BAEUERIN: { name: 'Boy-Butter B√§uerin', team: 'dorf', nightAction: true, actionType: 'find_baerbel', order: 65, condition: 'baerbel_not_found' },
            Oeko_Sabine: { name: '√ñko Sabine', team: 'dorf', nightAction: true, actionType: 'sabine_actions', order: 15, special: 'sabine_interaction' }, // Kombiniert Info & Schutz
            BESTATTERIN_BRUNHILDE: { name: 'Bestatterin Brunhilde', team: 'dorf', nightAction: true, actionType: 'revive', uses: 1, order: 80, condition: 'player_is_dead' },
            TUERSTEHER_TONI: { name: 'Nicht-bin√§re T√ºrsteherperson Toni', team: 'dorf', nightAction: true, actionType: 'check_wolf', order: 50 },
            WACHMANN_WENZEL: { name: 'Wachmann Wenzel', team: 'dorf', nightAction: true, actionType: 'guard_village', uses: 1, order: 85 },
            FISTERIN_FRIDA: { name: 'Fisterin Frida', team: 'dorf', nightAction: true, actionType: 'find_wiebke', order: 60, special: 'dies_on_wolf_touch' },

            // Eigenes Ziel
            WUT_WIEBKE: { name: 'Wut Wiebke', team: 'eigen', nightAction: true, actionType: 'vote_with_wolves', order: 12, winCondition: 'last_alive' },
            SUIZID_SUSIE: { name: 'Suizid Susie', team: 'eigen', nightAction: false, winCondition: 'lynched_day_1' },
            DOPPELMORAL_DOERTHE: { name: 'Doppelmoral-D√∂rthe', team: 'dorf', nightAction: true, actionType: 'observe_wolves', order: 11, winCondition: 'dorf_wins' }, // Gewinnt mit Dorf, obwohl sie aufwacht
            KONVERSIONSTHERAPIE_KONNY: { name: 'Konversionstherapie Konny', team: 'dorf', nightAction: true, actionType: 'find_twink', order: 51 },
            GLORYHOLE_GUENNI: { name: 'Gloryhole G√ºnni', team: 'dorf', nightAction: false, dayAction: true, special: 'knows_twink_konny' }, // Nachtaktion nur f√ºr Schutz-Check
            BLUTMAGIERIN_BEATRIX: { name: 'Blutmagierin Beatrix', team: 'dorf', nightAction: false, dayAction: true, actionType: 'intervene_lynch', uses: 1 },

            // Sonderrollen
            KLATSCH_KAETHE: { name: 'Klatsch-K√§the', team: 'zusatz', nightAction: true, actionType: 'spread_rumor', uses: 3, order: 72 }, // Team h√§ngt vom Basis-Spieler ab
            VOLLSUFF_VALENTIN: { name: 'Vollsuff-Valentin', team: 'dorf', nightAction: true, actionType: 'link_three', frequency: 'firstNightOnly', uses: 1, order: 1 },
            WAHRSAGER_WEBERIN_WALTRAUD: { name: 'Wahrsager-Weberin Waltraud', team: 'dorf', nightAction: true, actionType: 'link_two', uses: 1, order: 2 },

            // Gef√§hrliche / Unberechenbare
            KETA_ZIEHERIN_CLAUDIA: { name: 'Keta-Zieherin Claudia', team: 'dorf', nightAction: true, actionType: 'observe_all_but_wolves', frequency: 'oddNightsOnly', order: 20, special: 'dies_on_reveal' }, // Nacht 1, 3, 5...
            ILTUSSY: { name: 'Iltussy', team: 'dorf', nightAction: true, actionType: 'infect_roll', frequency: 'evenNightsOnly', order: 25 }, // Nacht 2, 4, 6...
            TRIP_SITTERIN_TANJA: { name: 'Trip-Sitterin Tanja', team: 'dorf', nightAction: true, actionType: 'retten_oder_ausschalten', uses: { retten: 1, ausschalten: 1 }, order: 30 },
            GIFT_MISCHERIN_GERTRUD: { name: 'Giftmischerin Gertrud', team: 'dorf', nightAction: true, actionType: 'poison', uses: 1, order: 31 }, // Korrigierter Key
            TRAVESTIEKUENSTLER_TRISTAN: { name: 'Travestiek√ºnstler Tristan', team: 'dorf', nightAction: false, dayAction: true, actionType: 'switch_team', uses: 1, special: 'can_become_wolf' }, // Team kann wechseln

            // Besondere Dynamik
            DER_TWINK: { name: 'Der Twink', team: 'dorf', nightAction: true, actionType: 'visit_and_learn', order: 50, special: 'hunted_by_priest' },
            DER_GEILE_PRIESTER: { name: 'Der geile Priester', team: 'dorf', nightAction: true, actionType: 'hunt_twink', order: 55 },

            // Werwolf
            WERWOLF: { name: 'Werwolf', team: 'werwolf', nightAction: true, actionType: 'kill', order: 10 },
        };

        // --- DOM Elemente (Variablen deklarieren) ---
        let allScreens, playerCountButtonsContainer, playerNameInputsContainer, btnGoToRoleAssignment,
            playerRoleAssignmentContainer, roleAssignmentError, btnStartGame, nightCounter,
            nightRoleAction, nightInstruction, nightPlayerList, nightSpecialUI, selectionInfo,
            btnNextAction, dayCounter, dayEventsList, dayEventAnnouncement, dayEventDetails,
            dayPlayerListStatus, btnStartDiscussion, dayCounterVote, dayVoteList, dayVoteTimer,
            dayVoteRestrictions, lynchSelectionInfo, beatrixInterventionDiv, btnBeatrixIntervene,
            beatrixResultSpan, btnConfirmLynch, lynchResultText, lynchRoleReveal, lynchConsequences,
            lynchPlayerListStatus, btnStartNextNight, gameOverMessage, winnersList, btnNewGame,
            btnEventsYes, btnEventsNo;

        let discussionTimerInterval = null; // F√ºr den Timer

        // --- Hilfsfunktionen ---
        function initializeDOMElements() {
            allScreens = document.querySelectorAll('.screen');
            playerCountButtonsContainer = document.getElementById('player-count-buttons');
            playerNameInputsContainer = document.getElementById('player-name-inputs');
            btnGoToRoleAssignment = document.getElementById('btn-go-to-role-assignment');
            playerRoleAssignmentContainer = document.getElementById('player-role-assignment');
            roleAssignmentError = document.getElementById('role-assignment-error');
            btnStartGame = document.getElementById('btn-start-game');
            nightCounter = document.getElementById('night-counter');
            nightRoleAction = document.getElementById('night-role-action');
            nightInstruction = document.getElementById('night-instruction');
            nightPlayerList = document.getElementById('night-player-list');
            nightSpecialUI = document.getElementById('night-special-ui');
            selectionInfo = document.getElementById('selection-info');
            btnNextAction = document.getElementById('btn-next-action');
            dayCounter = document.getElementById('day-counter');
            dayEventsList = document.getElementById('day-events-list');
            dayEventAnnouncement = document.getElementById('day-event-announcement');
            dayEventDetails = document.getElementById('day-event-details');
            dayPlayerListStatus = document.getElementById('day-player-list-status');
            btnStartDiscussion = document.getElementById('btn-start-discussion');
            dayCounterVote = document.getElementById('day-counter-vote');
            dayVoteList = document.getElementById('day-vote-list');
            dayVoteTimer = document.getElementById('day-vote-timer');
            dayVoteRestrictions = document.getElementById('day-vote-restrictions');
            lynchSelectionInfo = document.getElementById('lynch-selection-info');
            beatrixInterventionDiv = document.getElementById('beatrix-intervention');
            btnBeatrixIntervene = document.getElementById('btn-beatrix-intervene');
            beatrixResultSpan = document.getElementById('beatrix-result');
            btnConfirmLynch = document.getElementById('btn-confirm-lynch');
            lynchResultText = document.getElementById('lynch-result-text');
            lynchRoleReveal = document.getElementById('lynch-role-reveal');
            lynchConsequences = document.getElementById('lynch-consequences');
            lynchPlayerListStatus = document.getElementById('lynch-player-list-status');
            btnStartNextNight = document.getElementById('btn-start-next-night');
            gameOverMessage = document.getElementById('game-over-message');
            winnersList = document.getElementById('winners-list');
            btnNewGame = document.getElementById('btn-new-game');
            btnEventsYes = document.getElementById('btn-events-yes');
            btnEventsNo = document.getElementById('btn-events-no');
        }

        function showScreen(screenId) {
            if (!allScreens) initializeDOMElements(); // Sicherstellen, dass Elemente initialisiert sind
            allScreens.forEach(screen => {
                screen.classList.remove('active');
            });
            const screenToShow = document.getElementById(screenId);
            if (screenToShow) {
                screenToShow.classList.add('active');
                gameState.currentScreen = screenId;
                console.log("Showing screen:", screenId);
            } else {
                console.error("Screen not found:", screenId);
                showScreen('screen-setup-players');
            }
        }

        function getPlayerData(playerId) {
            return gameState.players.find(p => p.id === playerId);
        }
        function getPlayerByName(playerName) {
             return gameState.players.find(p => p.name === playerName);
        }

        function getLivingPlayers(team = null) {
            return gameState.players.filter(p => p.status === 'alive' && (team === null || p.roleDetails.team === team || (team === 'dorf' && p.roleDetails.winCondition === 'dorf_wins')));
        }

        function getDeadPlayers() {
            return gameState.players.filter(p => p.status === 'dead');
        }

        function getRoleDefinitionByKey(roleKey) {
            return ROLES[roleKey];
        }

        function getRoleDefinitionByName(roleName) {
            return Object.values(ROLES).find(r => r.name === roleName);
        }

        function logGameEvent(message) {
            console.log(message); // F√ºr Debugging in der Konsole
            gameState.gameLog.push({ time: new Date().toLocaleTimeString(), message: message });
            // Optional: gameLog im UI anzeigen
        }

        function showTemporaryMessage(elementId, message, duration = 3000) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = message;
                element.classList.remove('hidden');
                setTimeout(() => {
                    element.textContent = '';
                    element.classList.add('hidden');
                }, duration);
            }
        }

         // Funktion zum Abrufen des F√§higkeitsstatus (verbleibende Nutzungen)
        function getAbilityUses(playerId, abilityKey = null) {
            const player = getPlayerData(playerId);
            if (!player || !player.roleDetails?.uses) return Infinity; // Korrigiert: Pr√ºfe auf roleDetails.uses

            const usesLimit = player.roleDetails.uses;
            const currentUses = gameState.usedAbilities[playerId];

            if (typeof usesLimit === 'number' && usesLimit !== -1) {
                return Math.max(0, usesLimit - (currentUses || 0)); // Sicherstellen, dass nicht negativ
            } else if (typeof usesLimit === 'object' && abilityKey) {
                 // Pr√ºfen ob currentUses und currentUses[abilityKey] existieren
                 const usedCount = (currentUses && currentUses[abilityKey] !== undefined) ? currentUses[abilityKey] : 0;
                 return Math.max(0, usesLimit[abilityKey] - usedCount);
            } else if (typeof usesLimit === 'object') {
                // Gibt zur√ºck, ob *irgendeine* F√§higkeit noch Nutzungen hat
                const currentAbilityUses = currentUses || {};
                return Object.keys(usesLimit).some(key => (currentAbilityUses[key] || 0) < usesLimit[key]);
            }
             // Fallback f√ºr uses: 1 (wenn nicht als Zahl oder Objekt definiert)
             else if (usesLimit === 1) {
                 return 1 - (currentUses || 0);
             }
            return Infinity; // Unbegrenzt
        }

        // Funktion zum Markieren einer F√§higkeit als genutzt
        function markAbilityUsed(playerId, subAction = null) {
            const player = getPlayerData(playerId);
            if (!player || !player.roleDetails?.uses) return; // Korrigiert: Pr√ºfe auf roleDetails.uses

            // Initialisiere usedAbilities f√ºr den Spieler, falls noch nicht vorhanden
            if (!gameState.usedAbilities[playerId]) {
                gameState.usedAbilities[playerId] = {};
            }

            const usesLimit = player.roleDetails.uses;

            if (typeof usesLimit === 'number' && usesLimit !== -1) {
                // Einfacher Z√§hler f√ºr die Rolle
                gameState.usedAbilities[playerId] = (gameState.usedAbilities[playerId] || 0) + 1;
                logGameEvent(`${player.name} (${player.role}) hat F√§higkeit genutzt (${getAbilityUses(playerId)} verbleibend).`);
            } else if (typeof usesLimit === 'object' && subAction) {
                // Z√§hler pro F√§higkeitstyp
                gameState.usedAbilities[playerId][subAction] = (gameState.usedAbilities[playerId][subAction] || 0) + 1;
                logGameEvent(`${player.name} (${player.role}) hat F√§higkeit '${subAction}' genutzt (${getAbilityUses(playerId, subAction)} verbleibend).`);
            } else if (usesLimit === 1) {
                 // Fallback f√ºr Rollen, die nur uses: 1 haben
                 gameState.usedAbilities[playerId] = (gameState.usedAbilities[playerId] || 0) + 1;
                 logGameEvent(`${player.name} (${player.role}) hat einmalige F√§higkeit genutzt.`);
            }
        }


        // --- Spiel-Setup ---
        function setupPlayerCountButtons() {
            if (!playerCountButtonsContainer) return; // Sicherstellen, dass das Element existiert
            playerCountButtonsContainer.innerHTML = '';
            for (let i = 8; i <= 15; i++) {
                const button = document.createElement('button');
                button.textContent = i;
                button.value = i;
                button.onclick = () => selectPlayerCount(i);
                playerCountButtonsContainer.appendChild(button);
            }
        }

        function selectPlayerCount(count) {
            gameState.playerCount = count;
            logGameEvent(`Spieleranzahl auf ${count} gesetzt.`);
            setupNameInputs(); // Erstellt die Spielerobjekte neu
            showScreen('screen-setup-names');
        }

        function setupNameInputs() {
            if (!playerNameInputsContainer) return;
            playerNameInputsContainer.innerHTML = '';
            gameState.players = []; // Reset players array
            for (let i = 0; i < gameState.playerCount; i++) {
                const div = document.createElement('div');
                div.classList.add('flex', 'items-center', 'space-x-2', 'mb-2');
                const label = document.createElement('label');
                label.textContent = `Spieler ${i + 1}:`;
                label.htmlFor = `player-name-${i}`;
                label.classList.add('w-20', 'flex-shrink-0');
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `player-name-${i}`;
                input.placeholder = `Name Spieler ${i + 1}`;
                input.value = `Spieler ${i + 1}`; // Default name
                input.classList.add('flex-grow');
                div.appendChild(label);
                div.appendChild(input);
                playerNameInputsContainer.appendChild(div);

                // Add player object placeholder
                gameState.players.push({
                    id: `player-${i}`,
                    name: input.value, // Use default name initially
                    role: null,
                    roleKey: null,
                    roleDetails: null,
                    status: 'alive',
                    isProtected: false,
                    isPoisoned: false,
                    poisonTimer: 0,
                    linkedTo: [],
                    clientForDielenschleiferin: false,
                    misc: {}
                });
            }
        }

        // NEU: Funktion zum Speichern der Namen vor dem Wechsel zum Rollen-Screen
        function saveNamesAndGoToRoles() {
            if (gameState.players.length !== gameState.playerCount) {
                console.error("Player array size mismatch before saving names.");
                // Optional: Fehler anzeigen oder setupNameInputs() erneut aufrufen
                return;
            }
            gameState.players.forEach((player, i) => {
                const nameInput = document.getElementById(`player-name-${i}`);
                if (nameInput) {
                    player.name = nameInput.value.trim() || `Spieler ${i + 1}`;
                }
            });
            logGameEvent("Spielernamen gespeichert.");
            console.log("Updated player names:", gameState.players.map(p => p.name));
            setupRoleAssignment(); // Jetzt den Rollen-Screen aufbauen
        }


        function setupRoleAssignment() {
            if (!playerRoleAssignmentContainer) return; // Element-Check
            playerRoleAssignmentContainer.innerHTML = '';
            roleAssignmentError.classList.add('hidden');
            roleAssignmentError.textContent = '';

            // Rollen f√ºr Dropdown vorbereiten
            const availableRoles = Object.keys(ROLES).map(key => ({ key: key, name: ROLES[key].name }));
            availableRoles.sort((a, b) => a.name.localeCompare(b.name)); // Alphabetisch sortieren

            // Sicherstellen, dass gameState.players die korrekte Anzahl hat
             if (gameState.players.length !== gameState.playerCount) {
                 console.error("Player array size mismatch in setupRoleAssignment. Expected:", gameState.playerCount, "Got:", gameState.players.length);
                 roleAssignmentError.textContent = "Fehler: Spielerdaten nicht konsistent. Bitte neu starten.";
                 roleAssignmentError.classList.remove('hidden');
                 return; // Abbruch
             }

            gameState.players.forEach((player, i) => {
                const div = document.createElement('div');
                div.classList.add('flex', 'items-center', 'space-x-2', 'mb-2');
                const nameLabel = document.createElement('span');
                nameLabel.textContent = `${player.name}:`; // Namen aus gameState verwenden
                nameLabel.classList.add('w-32', 'flex-shrink-0', 'truncate');

                const select = document.createElement('select');
                select.id = `player-role-${i}`;
                select.classList.add('flex-grow');
                select.dataset.playerId = player.id; // Store player id

                const defaultOption = document.createElement('option');
                defaultOption.value = "";
                defaultOption.textContent = "Rolle ausw√§hlen...";
                select.appendChild(defaultOption);

                availableRoles.forEach(role => {
                    const option = document.createElement('option');
                    option.value = role.key;
                    option.textContent = role.name;
                    if (player.roleKey === role.key) { // Pre-select if already set
                        option.selected = true;
                    }
                    select.appendChild(option);
                });

                div.appendChild(nameLabel);
                div.appendChild(select);
                playerRoleAssignmentContainer.appendChild(div);
            });
            showScreen('screen-setup-roles');
        }

        function validateAndStartGame() {
            const assignedRolesMap = new Map();
            let isValid = true;
            let errorMessage = "";
            roleAssignmentError.classList.add('hidden');
            let assignedRoleKeys = [];

            // 1. Rollen auslesen und Spielern zuweisen
            for (let i = 0; i < gameState.playerCount; i++) {
                const select = document.getElementById(`player-role-${i}`);
                if (!select) {
                    isValid = false; errorMessage = `Fehler: Rollen-Auswahl f√ºr Spieler ${i+1} nicht gefunden.`; break;
                }
                const roleKey = select.value;
                const playerId = select.dataset.playerId;
                const player = getPlayerData(playerId);

                if (!player) {
                    isValid = false; errorMessage = `Interner Fehler: Spielerdaten f√ºr ID ${playerId} nicht gefunden.`; break;
                }
                if (!roleKey) {
                    isValid = false; errorMessage = `Bitte f√ºr Spieler ${player.name} eine Rolle ausw√§hlen.`; break;
                }

                player.roleKey = roleKey;
                player.roleDetails = ROLES[roleKey];
                player.role = player.roleDetails.name;
                assignedRoleKeys.push(roleKey);
                assignedRolesMap.set(roleKey, (assignedRolesMap.get(roleKey) || 0) + 1);

                // F√§higkeiten initialisieren
                player.misc = {}; // Reset misc data
                gameState.usedAbilities[player.id] = {}; // Reset used abilities
                 if (player.roleDetails.uses) {
                    if (typeof player.roleDetails.uses === 'number' && player.roleDetails.uses !== -1) {
                         gameState.usedAbilities[player.id] = 0;
                    } else if (typeof player.roleDetails.uses === 'object') {
                         for (const key in player.roleDetails.uses) {
                             gameState.usedAbilities[player.id][key] = 0;
                         }
                    }
                 } else if (player.roleDetails.uses === 1) {
                     gameState.usedAbilities[player.id] = 0;
                 }

                 if (player.roleKey === 'DOPPELMORAL_DOERTHE') {
                     player.misc.knowsWerwolves = true;
                 }
            }

            if (!isValid) {
                roleAssignmentError.textContent = errorMessage;
                roleAssignmentError.classList.remove('hidden');
                return;
            }

             // Post-assignment initializations
             gameState.players.forEach(player => {
                 if (player.roleKey === 'GLORYHOLE_GUENNI') {
                     const twink = gameState.players.find(p => p.roleKey === 'DER_TWINK');
                     const konny = gameState.players.find(p => p.roleKey === 'KONVERSIONSTHERAPIE_KONNY');
                     player.misc.knowsTwinkId = twink ? twink.id : null;
                     player.misc.knowsKonnyId = konny ? konny.id : null;
                     logGameEvent(`Gloryhole G√ºnni Initialisierung: Kennt Twink (${!!player.misc.knowsTwinkId}), Kennt Konny (${!!player.misc.knowsKonnyId})`);
                 }
             });

            // 2. Werwolfanzahl pr√ºfen
            const expectedWWCount = gameState.config.werwolfCount[gameState.playerCount];
            const actualWWCount = assignedRolesMap.get('WERWOLF') || 0;
            if (actualWWCount !== expectedWWCount) {
                isValid = false;
                errorMessage = `Falsche Anzahl Werw√∂lfe! F√ºr ${gameState.playerCount} Spieler werden ${expectedWWCount} ben√∂tigt, aber ${actualWWCount} wurden zugewiesen.`;
            }

            // 3. Inkompatible Rollen pr√ºfen
            if (assignedRoleKeys.includes('VOLLSUFF_VALENTIN') && assignedRoleKeys.includes('WAHRSAGER_WEBERIN_WALTRAUD')) {
                isValid = false; errorMessage = "Vollsuff-Valentin und Wahrsager-Weberin Waltraud d√ºrfen nicht im selben Spiel sein.";
            }
            if (assignedRoleKeys.includes('WUT_WIEBKE') && assignedRoleKeys.includes('DOPPELMORAL_DOERTHE')) {
                isValid = false; errorMessage = "Wut Wiebke und Doppelmoral-D√∂rthe d√ºrfen nicht im selben Spiel sein.";
            }
            // Pr√ºfung: Sind ben√∂tigte Rollen vorhanden?
            const requiredPairs = [
                ['BOY_BUTTER_BAEUERIN', 'BORDELL_BAERBEL', 'Die Boy-Butter B√§uerin ben√∂tigt Bordell B√§rbel im Spiel.'],
                ['KONVERSIONSTHERAPIE_KONNY', 'DER_TWINK', 'Konversionstherapie Konny ben√∂tigt den Twink im Spiel.'],
                ['DER_GEILE_PRIESTER', 'DER_TWINK', 'Der geile Priester ben√∂tigt den Twink im Spiel.'],
                ['FISTERIN_FRIDA', 'WUT_WIEBKE', 'Fisterin Frida ben√∂tigt Wut Wiebke im Spiel.']
            ];
            for (const [roleA, roleB, msg] of requiredPairs) {
                if (assignedRoleKeys.includes(roleA) && !assignedRoleKeys.includes(roleB)) {
                    isValid = false; errorMessage = msg; break;
                }
            }
             if (assignedRoleKeys.includes('GLORYHOLE_GUENNI') && (!assignedRoleKeys.includes('DER_TWINK') || !assignedRoleKeys.includes('KONVERSIONSTHERAPIE_KONNY'))) {
                 isValid = false; errorMessage = "Gloryhole G√ºnni ben√∂tigt den Twink UND Konversionstherapie Konny im Spiel.";
            }


            if (!isValid) {
                roleAssignmentError.textContent = errorMessage;
                roleAssignmentError.classList.remove('hidden');
                return;
            }

            // Reset game state variables before starting
            gameState.night = 0;
            gameState.day = 0;
            gameState.nightActions = [];
            gameState.lynchTarget = null;
            gameState.gameLog = ['Spiel gestartet'];
            gameState.specialConditions.linkedPlayers = [];
            gameState.specialConditions.twinkDeactivated = false;
            gameState.specialConditions.bauerFoundBaerbel = false;
            // eventsEnabled wird separat gesetzt
            gameState.specialConditions.lastEventDay = 0;
            gameState.specialConditions.activeEvent = null;


            logGameEvent("Rollen zugewiesen und validiert. Spiel startet.");
            console.log("Final Player Setup:", JSON.parse(JSON.stringify(gameState.players))); // Deep copy for logging
            console.log("Initial Used Abilities:", JSON.parse(JSON.stringify(gameState.usedAbilities)));
            showScreen('screen-setup-events'); // Gehe zur Event-Auswahl
        }

        function setupEvents(enabled) {
            gameState.specialConditions.eventsEnabled = enabled;
            logGameEvent(`Sonderereignisse ${enabled ? 'aktiviert' : 'deaktiviert'}.`);
            startNightPhase();
        }


        // --- Nachtphase Logik ---
        function startNightPhase() {
            gameState.night++;
            gameState.day = gameState.night; // Tag-Nummer entspricht der *kommenden* Tagesphase
            gameState.currentRoleIndex = -1;
            gameState.nightActions = [];
            gameState.lynchTarget = null;
            selectionInfo.textContent = '';
            nightSpecialUI.innerHTML = '';

            // Reset n√§chtliche Status / Infos
            gameState.players.forEach(p => {
                p.isProtected = false;
                p.clientForDielenschleiferin = false; // Wird jede Nacht neu gesetzt
                delete p.misc.sabineRolledSix;
                delete p.misc.priesterProtectedThisNight;
                delete p.misc.bauerProtectedThisNight;
                delete p.misc.baerbelSelfProtect;
                 // Chaos-Trank und WW-Blockade werden in resolveNightActions ausgewertet und m√ºssen nicht hier resettet werden
            });

            // Rollen f√ºr die Nachtphase filtern und sortieren
            gameState.rolesActingTonight = gameState.players
                .filter(p => p.status === 'alive' && p.roleDetails.nightAction)
                .filter(p => checkRoleCondition(p)) // Pr√ºfen, ob die Rolle aktiv ist (Frequenz, Nutzungslimit etc.)
                .sort((a, b) => (a.roleDetails.order || 999) - (b.roleDetails.order || 999)); // Sortieren nach Reihenfolge

            logGameEvent(`Nacht ${gameState.night} beginnt. Aktive Rollen: ${gameState.rolesActingTonight.map(p => p.role).join(', ')}`);
            nightCounter.textContent = gameState.night;
            showScreen('screen-night');
            nextNightAction();
        }

        function checkRoleCondition(player) {
            const role = player.roleDetails;
            const roleKey = player.roleKey;

            // Frequenz pr√ºfen
            if (role.frequency === 'firstNightOnly' && gameState.night !== 1) return false;
            if (role.frequency === 'oddNightsOnly' && gameState.night % 2 === 0) return false; // Ungerade N√§chte (1, 3, 5...)
            if (role.frequency === 'evenNightsOnly' && gameState.night % 2 !== 0) return false; // Gerade N√§chte (2, 4, 6...)

            // Nutzungslimit pr√ºfen
             if (role.uses) {
                 const usesLimit = role.uses;
                 const currentUses = gameState.usedAbilities[player.id];

                 if (typeof usesLimit === 'number' && usesLimit !== -1) {
                     // Einfache Z√§hlung (z.B. uses: 1)
                     if ((currentUses || 0) >= usesLimit) return false;
                 } else if (typeof usesLimit === 'object') {
                     // Z√§hlung pro F√§higkeit (z.B. uses: { retten: 1, ausschalten: 1 })
                     const currentAbilityUses = currentUses || {};
                     const canUseAny = Object.keys(usesLimit).some(key => (currentAbilityUses[key] || 0) < usesLimit[key]);
                     if (!canUseAny) return false;
                 }
                 // uses: -1 bedeutet unendlich, immer true
             }


            // Spezielle Bedingungen pr√ºfen
            if (role.condition === 'player_is_dead' && getDeadPlayers().length === 0) return false;
            if (role.condition === 'baerbel_not_found' && gameState.specialConditions.bauerFoundBaerbel) return false;
            if (roleKey === 'DER_TWINK' && gameState.specialConditions.twinkDeactivated) return false; // Konny hat ihn gefunden

            return true; // Rolle ist aktiv
        }


        function nextNightAction() {
            // Reset UI Elemente f√ºr die n√§chste Aktion
            nightSpecialUI.innerHTML = '';
            selectionInfo.textContent = '';
            btnNextAction.disabled = true; // Standardm√§√üig deaktiviert, bis Auswahl getroffen oder nicht n√∂tig
            btnNextAction.textContent = 'Aktion best√§tigen / N√§chster Schritt';
            btnNextAction.onclick = defaultNextActionButtonLogic; // Standard-Logik f√ºr den Button

            // Index erh√∂hen
            gameState.currentRoleIndex++;

            // Pr√ºfen, ob alle Rollen durch sind
            if (gameState.currentRoleIndex >= gameState.rolesActingTonight.length) {
                logGameEvent("Alle Nachtaktionen abgeschlossen.");
                resolveNightActions();
                return;
            }

            const currentPlayer = gameState.rolesActingTonight[gameState.currentRoleIndex];
            // Extra Check, falls currentPlayer undefiniert ist (sollte nicht passieren)
             if (!currentPlayer) {
                 console.error("Error: currentPlayer is undefined in nextNightAction. Index:", gameState.currentRoleIndex, "Roles acting:", gameState.rolesActingTonight);
                 resolveNightActions(); // Versuche, die Nacht trotzdem abzuschlie√üen
                 return;
             }
            const role = currentPlayer.roleDetails;
            const roleKey = currentPlayer.roleKey;

            // √úberspringe passive oder redundante Aktionen
             if (role.actionType === 'observe_passive' || role.actionType === 'vote_with_wolves' || role.actionType === 'observe_wolves') {
                 logGameEvent(`√úberspringe passive Rolle: ${currentPlayer.name} (${currentPlayer.role})`);
                 setTimeout(nextNightAction, 50); // Kurze Verz√∂gerung, dann n√§chste Aktion
                 return;
             }
             // √úberspringe weitere Werw√∂lfe, wenn der erste schon gew√§hlt hat
             if (roleKey === 'WERWOLF' && gameState.nightActions.some(a => a.roleKey === 'WERWOLF' && a.action === 'kill')) {
                 logGameEvent(`√úberspringe weiteren Werwolf: ${currentPlayer.name}`);
                 setTimeout(nextNightAction, 50);
                 return;
             }

            // --- UI f√ºr die aktuelle Rolle vorbereiten ---
            logGameEvent(`Aktion f√ºr: ${currentPlayer.name} (${currentPlayer.role})`);
            nightRoleAction.textContent = `${currentPlayer.role} (${currentPlayer.name}), deine Aktion:`;

            let instruction = "";
            let targetType = 'player'; // player, multi-player, dead_player, special, none, player_optional
            let targetCount = 1;
            // Standard: Alle anderen Lebenden sind w√§hlbar
            let selectablePlayers = getLivingPlayers().filter(p => p.id !== currentPlayer.id);
            let requiresUIInteraction = true; // Bestimmt, ob der "Weiter"-Button sofort aktiv sein soll

            // --- Rollenspezifische UI und Logik ---
            switch (role.actionType) {
                 case 'kill': // Werwolf
                    nightRoleAction.textContent = `Werw√∂lfe, w√§hlt euer Opfer:`;
                    instruction = "Zeigt auf den Spieler, den ihr fressen wollt.";
                    selectablePlayers = getLivingPlayers().filter(p => p.roleDetails.team !== 'werwolf');
                    if (selectablePlayers.length === 0) { // Nur noch W√∂lfe √ºbrig?
                        instruction = "Es gibt niemanden mehr zu fressen.";
                        targetType = 'none';
                        requiresUIInteraction = false;
                    }
                    break;
                case 'choose_client': // Dielenschleiferin
                    instruction = "W√§hle einen Spieler, bei dem du morgen die Dielen schleifst.";
                    selectablePlayers = getLivingPlayers(); // Kann jeden w√§hlen
                    targetType = 'player_optional'; // Kann √ºberspringen
                    break;
                 case 'protect_neighbor': // Schutzschild-Sigrid
                    const neighbors = getNeighbors(currentPlayer.id);
                    instruction = `W√§hle einen deiner Nachbarn (${neighbors.map(n => n.name).join(' oder ')}) zum Besch√ºtzen. (${getAbilityUses(currentPlayer.id)} √ºbrig)`;
                    selectablePlayers = neighbors;
                    targetType = 'player_optional';
                    if (neighbors.length === 0) {
                        instruction = "Du hast keine lebenden Nachbarn mehr zum Besch√ºtzen.";
                        targetType = 'none';
                        requiresUIInteraction = false;
                    }
                    break;
                case 'protect_guest': // Bordell B√§rbel
                    instruction = "Wen l√§dst du heute Nacht zu dir ein?";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'reveal_role': // Mansplaining Martin
                    instruction = "W√§hle einen Spieler, dessen Rolle du erfahren m√∂chtest.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'use_potion': // Kr√§uterhexe Hilde
                    instruction = "W√§hle einen Trank und ein Ziel.";
                    targetType = 'special';
                    setupHildeUI(currentPlayer);
                    requiresUIInteraction = false; // UI hat eigene Best√§tigung/Skip
                    break;
                case 'ask_dead': // Nekromant Norbert
                    instruction = `W√§hle einen toten Spieler als Medium und einen lebenden Spieler. (${getAbilityUses(currentPlayer.id)} √ºbrig)`;
                    targetType = 'special';
                    setupNorbertUI(currentPlayer);
                    requiresUIInteraction = false;
                    break;
                case 'find_baerbel': // Boy-Butter B√§uerin
                    instruction = "W√§hle einen Spieler und frage, ob es Bordell B√§rbel ist.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'sabine_actions': // √ñko Sabine
                    if (gameState.night === 1) {
                        instruction = "Der SL zeigt dir 3 m√∂gliche Werw√∂lfe (nur 1 ist korrekt).";
                        targetType = 'none';
                        const potentialTargets = getSabineTargets();
                        nightSpecialUI.innerHTML = `<p class="text-yellow-400">M√∂gliche Werw√∂lfe: ${potentialTargets.map(p=>p.name).join(', ')}</p>`;
                        requiresUIInteraction = false; // Nur Info
                    } else {
                        instruction = "W√ºrfle, um dich zu sch√ºtzen (ben√∂tigt eine 6).";
                        targetType = 'special';
                        setupSabineDiceUI(currentPlayer);
                        requiresUIInteraction = false; // UI hat eigene Logik
                    }
                    break;
                case 'revive': // Bestatterin Brunhilde
                     instruction = `W√§hle einen toten Spieler zur Wiederbelebung. (${getAbilityUses(currentPlayer.id)} √ºbrig)`;
                     selectablePlayers = getDeadPlayers();
                     targetType = 'dead_player_optional'; // Kann √ºberspringen
                     if (selectablePlayers.length === 0) {
                         instruction = "Es gibt niemanden zum Wiederbeleben.";
                         targetType = 'none';
                         requiresUIInteraction = false;
                     }
                     break;
                case 'check_wolf': // T√ºrsteher Toni
                    instruction = "W√§hle einen Spieler zum Abtasten.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'guard_village': // Wachmann Wenzel
                    instruction = `M√∂chtest du diese Nacht √ºber das Dorf wachen? (${getAbilityUses(currentPlayer.id)} √ºbrig)`;
                    targetType = 'special';
                    setupWenzelUI(currentPlayer);
                    requiresUIInteraction = false;
                    break;
                case 'find_wiebke': // Fisterin Frida
                    instruction = "W√§hle einen Spieler, um zu pr√ºfen, ob es Wut Wiebke ist. Vorsicht vor Werw√∂lfen!";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'find_twink': // Konversionstherapie Konny
                    instruction = "W√§hle einen Spieler, um zu pr√ºfen, ob es der Twink ist.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'spread_rumor': // Klatsch-K√§the
                    instruction = `W√§hle ein Ger√ºcht und einen Spieler. (${getAbilityUses(currentPlayer.id)} √ºbrig)`;
                    targetType = 'special';
                    setupKaetheUI(currentPlayer);
                    requiresUIInteraction = false;
                    break;
                case 'link_three': // Vollsuff-Valentin
                    instruction = "W√§hle DREI Spieler, die das Tr√§rchen bilden sollen.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'multi-player';
                    targetCount = 3;
                    if (selectablePlayers.length < 3) {
                         instruction = "Nicht gen√ºgend Spieler zum Verkuppeln vorhanden.";
                         targetType = 'none';
                         requiresUIInteraction = false;
                    }
                    break;
                case 'link_two': // Wahrsager-Weberin Waltraud
                    instruction = `W√§hle ZWEI Spieler, die verwoben werden sollen. (${getAbilityUses(currentPlayer.id)} √ºbrig)`;
                    selectablePlayers = getLivingPlayers();
                    targetType = 'multi-player';
                    targetCount = 2;
                     if (selectablePlayers.length < 2) {
                         instruction = "Nicht gen√ºgend Spieler zum Verweben vorhanden.";
                         targetType = 'none';
                         requiresUIInteraction = false;
                    }
                    break;
                case 'observe_all_but_wolves': // Keta-Zieherin Claudia
                    instruction = "Du beobachtest die Vorg√§nge der Nacht (au√üer die Werwolf-Aktion). Der SL informiert dich.";
                    targetType = 'none';
                    nightSpecialUI.innerHTML = `<p class="text-gray-400">(Spielleiter gibt Informationen an Claudia)</p>`;
                    requiresUIInteraction = false;
                    break;
                case 'infect_roll': // Iltussy
                    instruction = "W√§hle einen Dorfbewohner, zu dem du einen Iltis schickst, und w√ºrfle.";
                    selectablePlayers = getLivingPlayers().filter(p => p.id !== currentPlayer.id && p.roleDetails.team === 'dorf');
                    targetType = 'special';
                     if (selectablePlayers.length === 0) {
                         instruction = "Keine g√ºltigen Ziele f√ºr den Iltis.";
                         targetType = 'none';
                         requiresUIInteraction = false;
                     } else {
                         setupIltussyUI(currentPlayer, selectablePlayers);
                         requiresUIInteraction = false;
                     }
                    break;
                case 'retten_oder_ausschalten': // Trip-Sitterin Tanja
                    instruction = "M√∂chtest du retten oder ausschalten?";
                    targetType = 'special';
                    setupTanjaUI(currentPlayer);
                    requiresUIInteraction = false;
                    break;
                case 'poison': // Giftmischerin Gertrud
                    instruction = `W√§hle einen Spieler zum Vergiften. (${getAbilityUses(currentPlayer.id)} √ºbrig)`;
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'visit_and_learn': // Der Twink
                    instruction = "W√§hle einen Spieler, den du besuchen m√∂chtest.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'hunt_twink': // Der geile Priester
                    instruction = "W√§hle einen Spieler, um zu pr√ºfen, ob es der Twink ist.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                default:
                    instruction = "Diese Rolle hat keine definierte Aktion f√ºr die App.";
                    targetType = 'none';
                    requiresUIInteraction = false;
                    logGameEvent(`Keine UI implementiert f√ºr ${role.actionType} von ${currentPlayer.role}`);
            }

            nightInstruction.textContent = instruction;

            // Rendere Spielerliste oder leere sie, wenn nicht ben√∂tigt
            if (targetType.startsWith('player') || targetType.startsWith('multi-player') || targetType.startsWith('dead_player')) {
                 renderNightPlayerList(currentPlayer, selectablePlayers, targetType, role.actionType, targetCount);
            } else {
                 renderNightPlayerList(currentPlayer, [], 'none'); // Leere Liste f√ºr 'special' oder 'none'
            }

            // Aktiviere/Deaktiviere "Weiter"-Button basierend darauf, ob eine UI-Interaktion n√∂tig ist
            btnNextAction.disabled = requiresUIInteraction;
            if (!requiresUIInteraction) {
                 btnNextAction.textContent = 'Weiter';
                 // Kurze Pause, damit der SL den Text lesen kann, bevor automatisch weitergegangen wird
                 setTimeout(() => {
                     // Nur weitermachen, wenn wir noch bei diesem Spieler sind und der Screen aktiv ist
                     if (gameState.currentScreen === 'screen-night' && gameState.rolesActingTonight[gameState.currentRoleIndex]?.id === currentPlayer.id) {
                          confirmNightAction(null); // Keine explizite Aktion vom Spieler n√∂tig
                     }
                 }, 1500); // 1.5 Sekunden Verz√∂gerung
            }
        }

        function defaultNextActionButtonLogic() {
             // Standard-Aktion f√ºr den "Weiter"-Button, wenn keine spezifische Logik zugewiesen wurde
             const currentPlayer = gameState.rolesActingTonight[gameState.currentRoleIndex];
             logGameEvent(`Weiter geklickt f√ºr ${currentPlayer?.name || 'unbekannt'}. Keine Aktion ausgew√§hlt oder n√∂tig.`);
             confirmNightAction(null); // Best√§tigt, dass keine Aktion gew√§hlt wurde oder die Aktion abgeschlossen ist
        }

        function confirmNightAction(actionData) {
            const currentPlayer = gameState.rolesActingTonight[gameState.currentRoleIndex];
            // Verhindere Best√§tigung, wenn Index nicht mehr stimmt (z.B. durch Timeout)
            if (!currentPlayer || gameState.currentRoleIndex >= gameState.rolesActingTonight.length) {
                 console.warn("confirmNightAction called but currentRoleIndex is out of bounds or currentPlayer is null.");
                 return;
            }

            if (actionData) {
                 let action = {
                    actor: currentPlayer.id,
                    role: currentPlayer.role,
                    roleKey: currentPlayer.roleKey, // F√ºge roleKey hinzu
                    action: currentPlayer.roleDetails.actionType,
                    ...actionData // F√ºgt target, targets, subAction etc. hinzu
                 };
                 gameState.nightActions.push(action);
                 logGameEvent(`Aktion gespeichert: ${JSON.stringify(action)}`);

                 // F√§higkeit als genutzt markieren, wenn es eine nutzungsbeschr√§nkte F√§higkeit war
                 if (action.action !== 'sabine_actions' || action.rolled !== 6) { // Sabine Schutzwurf z√§hlt nicht als Nutzung
                    markAbilityUsed(currentPlayer.id, action.subAction);
                 }


            } else {
                logGameEvent(`${currentPlayer.name} (${currentPlayer.role}) macht keine Aktion oder Aktion wurde √ºbersprungen.`);
            }
            // Zum n√§chsten Spieler/Aktion in der Nacht
            nextNightAction();
        }


        // --- UI Setup Funktionen f√ºr spezielle Rollen ---

        function setupHildeUI(player) {
            nightSpecialUI.innerHTML = '';
            const uses = player.roleDetails.uses;
            const used = gameState.usedAbilities[player.id] || {};
            const remaining = {
                protect: uses.protect - (used.protect || 0),
                block_ww: uses.block_ww - (used.block_ww || 0),
                chaos: uses.chaos - (used.chaos || 0)
            };

            const canUseAny = Object.values(remaining).some(count => count > 0);

            if (!canUseAny) {
                nightInstruction.textContent = "Du hast keine Tr√§nke mehr.";
                renderNightPlayerList(player, [], 'none');
                btnNextAction.textContent = 'Weiter';
                btnNextAction.disabled = false;
                btnNextAction.onclick = defaultNextActionButtonLogic; // Standard-Weiter-Logik
                return;
            }

            const selectLabel = document.createElement('label');
            selectLabel.textContent = "W√§hle einen Trank: ";
            selectLabel.htmlFor = 'hilde-potion-select';
            nightSpecialUI.appendChild(selectLabel);

            const selectPotion = document.createElement('select');
            selectPotion.id = 'hilde-potion-select';
            selectPotion.innerHTML = `<option value="">-- Bitte w√§hlen --</option>`;
            if (remaining.protect > 0) selectPotion.innerHTML += `<option value="protect">Schutztrank (${remaining.protect} √ºbrig)</option>`;
            if (remaining.block_ww > 0) selectPotion.innerHTML += `<option value="block_ww">Heil-/Blockadetrank (${remaining.block_ww} √ºbrig)</option>`;
            if (remaining.chaos > 0) selectPotion.innerHTML += `<option value="chaos">Chaostrank (${remaining.chaos} √ºbrig)</option>`;
            nightSpecialUI.appendChild(selectPotion);

            selectPotion.onchange = () => {
                const selectedPotion = selectPotion.value;
                if (selectedPotion) {
                    nightInstruction.textContent = `W√§hle einen Spieler f√ºr den ${ROLES.KRAEUTERHEXE_HILDE.name} (${selectedPotion}).`;
                    renderNightPlayerList(player, getLivingPlayers(), 'player', selectedPotion); // Zielauswahl erm√∂glichen
                    selectionInfo.textContent = 'W√§hle ein Ziel.';
                    btnNextAction.disabled = true; // Muss Ziel w√§hlen
                } else {
                    renderNightPlayerList(player, [], 'none'); // Keine Auswahl m√∂glich
                    selectionInfo.textContent = '';
                    btnNextAction.disabled = true;
                }
            };

             const skipButton = document.createElement('button');
             skipButton.textContent = "Keinen Trank verwenden";
             skipButton.classList.add('secondary', 'ml-4');
             skipButton.onclick = () => confirmNightAction(null);
             nightSpecialUI.appendChild(skipButton);

             renderNightPlayerList(player, [], 'none'); // Liste initial leer/inaktiv
             btnNextAction.disabled = true; // Muss erst Trank w√§hlen oder √ºberspringen
        }

        function setupNorbertUI(player) {
            nightSpecialUI.innerHTML = '';
            const deadPlayers = getDeadPlayers();
            const livingPlayers = getLivingPlayers();

            if (deadPlayers.length === 0 || livingPlayers.length === 0) {
                 nightInstruction.textContent = `Es gibt nicht gen√ºgend Spieler f√ºr deine F√§higkeit. (${getAbilityUses(player.id)} √ºbrig)`;
                 renderNightPlayerList(player, [], 'none');
                 btnNextAction.textContent = 'Weiter';
                 btnNextAction.disabled = false;
                 btnNextAction.onclick = defaultNextActionButtonLogic;
                 return;
            }

            nightSpecialUI.innerHTML = `
                <div class="flex flex-wrap gap-4 items-center">
                    <div>
                        <label for="norbert-dead-select" class="block mb-1 text-sm font-medium">W√§hle den Geist:</label>
                        <select id="norbert-dead-select">
                            <option value="">-- Toter Spieler --</option>
                            ${deadPlayers.map(p => `<option value="${p.id}">${p.name} (${p.role})</option>`).join('')}
                        </select>
                    </div>
                    <div>
                        <label for="norbert-living-select" class="block mb-1 text-sm font-medium">√úber wen fragst du?</label>
                        <select id="norbert-living-select">
                            <option value="">-- Lebender Spieler --</option>
                            ${livingPlayers.map(p => `<option value="${p.id}">${p.name}</option>`).join('')}
                        </select>
                    </div>
                    <button id="norbert-confirm" class="self-end" disabled>Best√§tigen & SL Info geben</button>
                     <button id="norbert-skip" class="secondary self-end">√úberspringen</button>
                </div>
            `;

            const deadSelect = document.getElementById('norbert-dead-select');
            const livingSelect = document.getElementById('norbert-living-select');
            const confirmBtn = document.getElementById('norbert-confirm');
            const skipBtn = document.getElementById('norbert-skip');


            function checkSelection() {
                confirmBtn.disabled = !(deadSelect.value && livingSelect.value);
            }

            deadSelect.onchange = checkSelection;
            livingSelect.onchange = checkSelection;

            confirmBtn.onclick = () => {
                const deadPlayerId = deadSelect.value;
                const livingPlayerId = livingSelect.value;
                const livingPlayer = getPlayerData(livingPlayerId);
                const deadPlayer = getPlayerData(deadPlayerId);
                const isWolf = livingPlayer.roleDetails.team === 'werwolf'; // Info f√ºr SL
                logGameEvent(`${player.name} befragt Geist ${deadPlayer.name} √ºber ${livingPlayer.name}.`);
                selectionInfo.textContent = `SL: Gib ${player.name} Info √ºber ${livingPlayer.name} (WW? ${isWolf ? 'Ja' : 'Nein'} - Daumen hoch/runter).`;
                confirmNightAction({ action: 'ask_dead', target: livingPlayer.name, medium: deadPlayer.name });
            };

             skipBtn.onclick = () => confirmNightAction(null);


            renderNightPlayerList(player, [], 'none'); // Keine Spielerliste n√∂tig
            btnNextAction.disabled = true; // Muss UI benutzen oder √ºberspringen
        }

        function setupSabineDiceUI(player) {
             nightSpecialUI.innerHTML = `
                <button id="sabine-roll-dice">W√ºrfeln f√ºr Schutz</button>
                <span id="sabine-dice-result" class="ml-4 text-xl font-bold"></span>
             `;
             const rollButton = document.getElementById('sabine-roll-dice');
             const resultSpan = document.getElementById('sabine-dice-result');

             rollButton.onclick = () => {
                 const roll = Math.floor(Math.random() * 6) + 1;
                 resultSpan.textContent = `W√ºrfel: ${roll}.`;
                 rollButton.disabled = true;
                 let protected = false;
                 if (roll === 6) {
                     player.misc.sabineRolledSix = true; // Im Spielerobjekt speichern
                     protected = true;
                     resultSpan.textContent += ' Gesch√ºtzt!';
                     resultSpan.classList.add('text-green-400');
                 } else {
                     resultSpan.textContent += ' Nicht gesch√ºtzt.';
                     resultSpan.classList.add('text-red-400');
                 }
                 logGameEvent(`${player.name} w√ºrfelt f√ºr Schutz: ${roll} (${protected ? 'gesch√ºtzt' : 'nicht gesch√ºtzt'}).`);
                 // Automatisch weiter nach kurzer Anzeige
                 setTimeout(() => {
                     if (gameState.currentScreen === 'screen-night' && gameState.rolesActingTonight[gameState.currentRoleIndex]?.id === player.id) {
                         // Keine Aktion speichern, da es ein passiver Effekt ist, der in resolveNightActions gepr√ºft wird
                         confirmNightAction(null);
                     }
                 }, 2500);
             };
             renderNightPlayerList(player, [], 'none');
             btnNextAction.disabled = true; // Aktion l√§uft √ºber W√ºrfel-Button
        }

         function setupWenzelUI(player) {
             nightSpecialUI.innerHTML = `
                <button id="wenzel-yes">Ja, ich wache! (${getAbilityUses(player.id)} √ºbrig)</button>
                <button id="wenzel-no" class="secondary">Nein, ich schlafe lieber.</button>
             `;
             document.getElementById('wenzel-yes').onclick = () => {
                 logGameEvent(`${player.name} entscheidet sich zu wachen.`);
                 selectionInfo.textContent = "Das Dorf wird diese Nacht bewacht.";
                 confirmNightAction({ action: 'guard_village', watches: true });
             };
             document.getElementById('wenzel-no').onclick = () => {
                 logGameEvent(`${player.name} entscheidet sich zu schlafen.`);
                 selectionInfo.textContent = "Wenzel schl√§ft.";
                 confirmNightAction({ action: 'guard_village', watches: false }); // Keine F√§higkeit verbraucht
             };
             renderNightPlayerList(player, [], 'none');
             btnNextAction.disabled = true; // Muss eine der Optionen w√§hlen
         }

         function setupKaetheUI(player) {
             nightSpecialUI.innerHTML = '';
             const rumors = [
                 "Man munkelt, dass du der Dorfgemeinschaft nicht wohlgesonnen bist.",
                 "Es gibt ein geheimes B√ºndnis im Dorf, und du scheinst darin verwickelt zu sein.",
                 "Man sagt, du hast eine d√ºstere Vorahnung √ºber das n√§chste Opfer ausgesprochen."
             ];
             const uses = player.roleDetails.uses;
             const usedCount = gameState.usedAbilities[player.id] || 0;
             const remaining = uses - usedCount;

             if (remaining <= 0) {
                 nightInstruction.textContent = "Du hast keine Ger√ºchte mehr zu verbreiten.";
                 renderNightPlayerList(player, [], 'none');
                 btnNextAction.textContent = 'Weiter';
                 btnNextAction.disabled = false;
                 btnNextAction.onclick = defaultNextActionButtonLogic;
                 return;
             }

             nightSpecialUI.innerHTML = `
                 <div class="space-y-2">
                    <div>
                        <label for="kaethe-rumor-select" class="block mb-1 text-sm font-medium">W√§hle ein Ger√ºcht (${remaining} √ºbrig):</label>
                        <select id="kaethe-rumor-select">
                            <option value="">-- Ger√ºcht w√§hlen --</option>
                            ${rumors.map((r, index) => `<option value="${index}">${r}</option>`).join('')}
                        </select>
                    </div>
                    <div>
                        <label for="kaethe-target-select" class="block mb-1 text-sm font-medium">√úber wen?</label>
                        <select id="kaethe-target-select" disabled>
                            <option value="">-- Spieler w√§hlen --</option>
                            ${getLivingPlayers().map(p => `<option value="${p.id}">${p.name}</option>`).join('')}
                        </select>
                    </div>
                    <button id="kaethe-confirm" class="mt-2" disabled>Ger√ºcht streuen</button>
                    <button id="kaethe-skip" class="secondary">√úberspringen</button>
                 </div>
             `;

             const rumorSelect = document.getElementById('kaethe-rumor-select');
             const targetSelect = document.getElementById('kaethe-target-select');
             const confirmBtn = document.getElementById('kaethe-confirm');
             const skipBtn = document.getElementById('kaethe-skip');

             function checkKaetheSelection() {
                 const rumorSelected = rumorSelect.value !== "";
                 const targetSelected = targetSelect.value !== "";
                 targetSelect.disabled = !rumorSelected;
                 confirmBtn.disabled = !(rumorSelected && targetSelected);
             }

             rumorSelect.onchange = checkKaetheSelection;
             targetSelect.onchange = checkKaetheSelection;

             confirmBtn.onclick = () => {
                 const targetPlayerId = targetSelect.value;
                 const rumorIndex = parseInt(rumorSelect.value);
                 const rumorText = rumors[rumorIndex];
                 logGameEvent(`${player.name} verbreitet Ger√ºcht '${rumorIndex + 1}' √ºber ${getPlayerData(targetPlayerId).name}.`);
                 selectionInfo.textContent = `Ger√ºcht √ºber ${getPlayerData(targetPlayerId).name} wird am Tag verk√ºndet.`;
                 confirmNightAction({ action: 'spread_rumor', target: getPlayerData(targetPlayerId).name, rumorIndex: rumorIndex, rumorText: rumorText });
             };

             skipBtn.onclick = () => confirmNightAction(null);

             renderNightPlayerList(player, [], 'none');
             btnNextAction.disabled = true; // Muss UI benutzen oder √ºberspringen
         }

         function setupIltussyUI(player, selectableTargets) {
             nightSpecialUI.innerHTML = `
                 <div>
                     <label for="iltussy-target-select" class="block mb-1 text-sm font-medium">W√§hle ein Ziel f√ºr den Iltis:</label>
                     <select id="iltussy-target-select">
                         <option value="">-- Spieler w√§hlen --</option>
                         ${selectableTargets.map(p => `<option value="${p.id}">${p.name}</option>`).join('')}
                     </select>
                 </div>
                 <div class="mt-2">
                     <button id="iltussy-roll-dice" disabled>W√ºrfeln</button>
                     <span id="iltussy-dice-result" class="ml-4 text-xl font-bold"></span>
                 </div>
                 <button id="iltussy-skip" class="secondary mt-2">√úberspringen</button>
             `;

             const targetSelect = document.getElementById('iltussy-target-select');
             const rollButton = document.getElementById('iltussy-roll-dice');
             const resultSpan = document.getElementById('iltussy-dice-result');
             const skipBtn = document.getElementById('iltussy-skip');

             targetSelect.onchange = () => {
                 rollButton.disabled = targetSelect.value === "";
             };

             rollButton.onclick = () => {
                 const targetPlayerId = targetSelect.value;
                 const targetPlayer = getPlayerData(targetPlayerId);
                 if (!targetPlayer) return;

                 const roll = Math.floor(Math.random() * 6) + 1;
                 resultSpan.textContent = `W√ºrfel: ${roll}.`;
                 rollButton.disabled = true;
                 targetSelect.disabled = true;
                 skipBtn.disabled = true;

                 let infection = false;
                 if (roll === 6) {
                     infection = true;
                     resultSpan.textContent += ` ${targetPlayer.name} wird infiziert!`;
                     resultSpan.classList.add('text-green-400');
                 } else {
                     resultSpan.textContent += ' Nichts passiert.';
                     resultSpan.classList.remove('text-green-400');
                 }
                 logGameEvent(`${player.name} schickt Iltis zu ${targetPlayer.name}, w√ºrfelt ${roll}. ${infection ? 'Infiziert!' : 'Keine Infektion.'}`);

                 setTimeout(() => {
                     if (gameState.currentScreen === 'screen-night' && gameState.rolesActingTonight[gameState.currentRoleIndex]?.id === player.id) {
                         confirmNightAction({ action: 'infect_roll', target: targetPlayer.name, rolled: roll, infected: infection });
                     }
                 }, 2500);
             };

             skipBtn.onclick = () => confirmNightAction(null);

             renderNightPlayerList(player, [], 'none');
             btnNextAction.disabled = true; // Muss UI benutzen oder √ºberspringen
         }

         function setupTanjaUI(player) {
            nightSpecialUI.innerHTML = '';
            const uses = player.roleDetails.uses;
            const used = gameState.usedAbilities[player.id] || {};
            const canRetten = (used.retten || 0) < uses.retten;
            const canAusschalten = (used.ausschalten || 0) < uses.ausschalten;
            // Finde das potenzielle WW-Opfer aus den bisherigen Aktionen DIESER Nacht
            const wwAction = gameState.nightActions.find(a => a.action === 'kill' && a.roleKey === 'WERWOLF');
            const wwOpferId = wwAction ? getPlayerByName(wwAction.target)?.id : null;
            const wwOpfer = getPlayerData(wwOpferId);
            const wwOpferName = wwOpfer?.name;

            if (!canRetten && !canAusschalten) {
                nightInstruction.textContent = "Du hast keine Aktionen mehr verf√ºgbar.";
                renderNightPlayerList(player, [], 'none');
                btnNextAction.textContent = 'Weiter';
                btnNextAction.disabled = false;
                btnNextAction.onclick = defaultNextActionButtonLogic;
                return;
            }

            let buttonsHTML = '';
            if (canRetten && wwOpfer && wwOpfer.status === 'alive') { // Nur retten, wenn es ein lebendes Opfer gibt
                buttonsHTML += `<button id="tanja-retten" data-target="${wwOpferName}">Opfer (${wwOpferName}) retten (${getAbilityUses(player.id, 'retten')} √ºbrig)</button>`;
            } else if (canRetten) {
                 buttonsHTML += `<button disabled class="secondary">Retten nicht m√∂glich (Kein WW-Opfer diese Nacht)</button>`;
            }

            if (canAusschalten) {
                buttonsHTML += `<button id="tanja-ausschalten">Jemanden ausschalten (${getAbilityUses(player.id, 'ausschalten')} √ºbrig)</button>`;
            }

            buttonsHTML += `<button id="tanja-skip" class="secondary">√úberspringen</button>`;
            nightSpecialUI.innerHTML = `<div class="flex flex-wrap gap-2">${buttonsHTML}</div>`;

            const btnRetten = document.getElementById('tanja-retten');
            const btnAusschalten = document.getElementById('tanja-ausschalten');
            const btnSkip = document.getElementById('tanja-skip');

            if (btnRetten) {
                btnRetten.onclick = () => {
                    const targetName = btnRetten.dataset.target;
                    logGameEvent(`${player.name} rettet ${targetName}.`);
                    selectionInfo.textContent = `${targetName} wurde gerettet.`;
                    confirmNightAction({ action: 'retten_oder_ausschalten', subAction: 'retten', target: targetName });
                };
            }

            if (btnAusschalten) {
                btnAusschalten.onclick = () => {
                    nightInstruction.textContent = "W√§hle einen Spieler zum Ausschalten.";
                    nightSpecialUI.innerHTML = ''; // Clear buttons
                    renderNightPlayerList(player, getLivingPlayers().filter(p => p.id !== player.id), 'player', 'ausschalten');
                    selectionInfo.textContent = 'W√§hle ein Ziel.';
                    btnNextAction.disabled = true; // Muss Ziel w√§hlen
                };
            }

            btnSkip.onclick = () => confirmNightAction(null);

            renderNightPlayerList(player, [], 'none'); // Liste initial leer/inaktiv
            btnNextAction.disabled = true; // Muss Aktion w√§hlen oder √ºberspringen
         }

        // --- Gemeinsame Render-Funktion f√ºr Spielerlisten ---
        function renderPlayerList(listElement, playersToRender, interactive = false, actionContext = null, targetCount = 1) {
            if (!listElement) {
                console.error("renderPlayerList: listElement is null or undefined.");
                return;
            }
            listElement.innerHTML = '';
            let currentSelection = []; // F√ºr Mehrfachauswahl

            // --- Hilfsfunktion zum Erstellen von Listenelementen ---
            const createPlayerListItem = (p) => {
                const li = document.createElement('li');
                li.dataset.playerId = p.id;

                const infoDiv = document.createElement('div');
                infoDiv.classList.add('player-info');
                const nameSpan = document.createElement('span');
                nameSpan.textContent = p.name;
                nameSpan.classList.add(p.status === 'alive' ? 'status-alive' : 'status-dead');
                infoDiv.appendChild(nameSpan);

                // Rolle nur anzeigen, wenn Spieler tot ist
                if (p.status === 'dead') {
                    const roleSpan = document.createElement('span');
                    roleSpan.textContent = ` (${p.role})`;
                    roleSpan.classList.add('role-info');
                    infoDiv.appendChild(roleSpan);
                }

                // Status-Icons hinzuf√ºgen
                const iconsDiv = document.createElement('div');
                iconsDiv.classList.add('flex', 'items-center', 'space-x-1', 'mt-1', 'md:mt-0');
                if (p.isProtected) iconsDiv.innerHTML += `<span class="icon icon-shield" title="Gesch√ºtzt">üõ°Ô∏è</span>`;
                if (p.isPoisoned) iconsDiv.innerHTML += `<span class="icon icon-potion" title="Vergiftet (${p.poisonTimer})">‚ò†Ô∏è</span>`;
                if (p.clientForDielenschleiferin) iconsDiv.innerHTML += `<span class="icon icon-tools" title="Dielenschleiferin-Kunde">üî®</span>`;
                if (gameState.specialConditions.linkedPlayers?.includes(p.id)) iconsDiv.innerHTML += `<span class="icon icon-heart" title="Verliebt/Verwoben">‚ù§Ô∏è</span>`;
                if (p.misc?.sabineRolledSix) iconsDiv.innerHTML += `<span class="icon icon-shield" title="Sabine Schutz (6)">üé≤</span>`;
                if (p.misc?.priesterProtectedThisNight) iconsDiv.innerHTML += `<span class="icon icon-shield" title="Priester Schutz">‚úùÔ∏è</span>`;
                if (p.misc?.bauerProtectedThisNight) iconsDiv.innerHTML += `<span class="icon icon-shield" title="B√§uerin Schutz">üßà</span>`;
                if (p.misc?.chaostrankActive) iconsDiv.innerHTML += `<span class="icon icon-potion" title="Chaos-Trank aktiv">ü§™</span>`;
                if (p.misc?.blockWWActive) iconsDiv.innerHTML += `<span class="icon icon-cross" title="WW Blockade aktiv">üö´</span>`;

                infoDiv.appendChild(iconsDiv);
                li.appendChild(infoDiv);

                // Interaktive Elemente (Buttons)
                const isSelectable = p.status === 'alive' && selectablePlayers.some(sp => sp.id === p.id);
                 // Check if targetType is valid before proceeding
                 if (interactive && targetType && targetType !== 'none') {
                    const actionsDiv = document.createElement('div');
                    actionsDiv.classList.add('player-actions');

                    if (isSelectable) {
                        const selectButton = document.createElement('button');
                        selectButton.textContent = 'W√§hlen';
                        selectButton.onclick = (event) => {
                            event.stopPropagation();
                            const targetName = p.name;
                            const targetId = p.id;

                            if (targetType === 'player' || targetType === 'dead_player') {
                                document.querySelectorAll(`#${listElement.id} li`).forEach(item => item.classList.remove('selected'));
                                li.classList.add('selected');
                                selectionInfo.textContent = `Ausgew√§hlt: ${targetName}`;
                                // Nur Aktion best√§tigen, wenn es eine Zielauswahl ist (nicht f√ºr Lynch)
                                if(actionContext !== 'lynch') {
                                    confirmNightAction({ target: targetName, subAction: actionContext });
                                } else {
                                    // F√ºr Lynch nur das Ziel setzen und Button aktivieren
                                    gameState.lynchTarget = targetName;
                                    lynchSelectionInfo.textContent = `Ausgew√§hlt f√ºr Lynchung: ${targetName}`;
                                    btnConfirmLynch.disabled = false;
                                    // Beatrix Button nur aktivieren, wenn ein Ziel gew√§hlt ist
                                    const beatrix = gameState.players.find(p => p.status === 'alive' && p.roleKey === 'BLUTMAGIERIN_BEATRIX');
                                    const beatrixAbilityUses = getAbilityUses(beatrix?.id);
                                    if (btnBeatrixIntervene) btnBeatrixIntervene.disabled = !(beatrix && beatrixAbilityUses > 0);
                                }
                            } else if (targetType === 'multi-player') {
                                li.classList.toggle('selected');
                                if (li.classList.contains('selected')) {
                                    if (!currentSelection.includes(targetName)) currentSelection.push(targetName);
                                } else {
                                    currentSelection = currentSelection.filter(name => name !== targetName);
                                }
                                selectionInfo.textContent = `Ausgew√§hlt (${currentSelection.length}/${targetCount}): ${currentSelection.join(', ')}`;
                                btnNextAction.disabled = currentSelection.length !== targetCount;
                                if (!btnNextAction.disabled) {
                                    btnNextAction.onclick = () => confirmNightAction({ targets: currentSelection, subAction: actionContext });
                                } else {
                                    btnNextAction.onclick = defaultNextActionButtonLogic;
                                }
                            }
                        };
                        actionsDiv.appendChild(selectButton);
                    } else {
                         // Mache lebende, aber nicht w√§hlbare Spieler leicht ausgegraut
                         if (p.status === 'alive') li.style.opacity = "0.5";
                    }
                    li.appendChild(actionsDiv);
                } else if (p.status === 'dead') {
                    // Tote Spieler immer ausgrauen
                    li.style.opacity = "0.6";
                }

                return li;
            };

             // F√ºge "Nichts tun / √úberspringen"-Button hinzu, wenn optional
             const isOptional = targetType && targetType.endsWith('_optional');
             if (interactive && isOptional && targetType !== 'special') {
                 const liSkip = document.createElement('li');
                 liSkip.style.backgroundColor = 'transparent';
                 const skipButton = document.createElement('button');
                 skipButton.textContent = 'Keine Aktion / √úberspringen';
                 skipButton.classList.add('secondary', 'w-full', 'mt-2');
                 skipButton.onclick = () => confirmNightAction(null);
                 liSkip.appendChild(skipButton);
                 listElement.appendChild(liSkip);
                 // Ensure targetType is reset for further logic if needed
                 targetType = targetType.replace('_optional', '');
             }


             // Spieler rendern
             playersToRender.forEach(p => {
                 listElement.appendChild(createPlayerListItem(p));
             });

             // Wenn nur Anzeige (nicht interaktiv), zeige alle Spieler (lebend/tot)
             if (!interactive) {
                 const allPlayers = gameState.players; // Hole alle Spieler
                 listElement.innerHTML = ''; // Leere die Liste nochmal
                 allPlayers.sort((a,b) => a.name.localeCompare(b.name)).forEach(p => { // Sortiere nach Namen f√ºr Anzeige
                     listElement.appendChild(createPlayerListItem(p)); // Erstelle Listenelement f√ºr jeden
                 });
             }
        }

        // --- Nacht Aktionsauswertung (resolveNightActions) ---
        function resolveNightActions() {
            logGameEvent("Beginne Aufl√∂sung der Nachtaktionen.");
            dayEventsList.innerHTML = '';
            let deathsThisNight = []; // Spieler-Objekte
            let messages = []; // String-Nachrichten f√ºr die Anzeige
            let nightSummary = {
                wwTarget: null, protections: {}, heals: [], poisons: [], blocks: [],
                chaosTargets: [], revives: [], infections: [], linked: [], linkedType: null,
                dielenClient: null, ausschaltenTarget: null, wenzelWatched: false,
                rumors: [], fridaTarget: null, fridaDied: false, twinkVisitTarget: null,
                twinkKilledByPriest: false, konnyTarget: null,
                twinkAbilityDeactivated: gameState.specialConditions.twinkDeactivated,
                priestTarget: null, bauerTarget: null,
                bauerFoundBaerbel: gameState.specialConditions.bauerFoundBaerbel,
                martinTarget: null, martinSawSabine: false, sabineProtected: false, sigridTarget: null
            };

            // --- 1. Aktionen sammeln ---
            gameState.nightActions.forEach(action => {
                const actor = getPlayerData(action.actor);
                if (!actor || actor.status !== 'alive') return;

                const targetPlayer = action.target ? getPlayerByName(action.target) : null;
                const targetId = targetPlayer?.id;
                const targets = action.targets ? action.targets.map(name => getPlayerByName(name)?.id).filter(id => id) : [];

                switch (action.action) {
                    case 'kill': nightSummary.wwTarget = targetId; break;
                    case 'choose_client': nightSummary.dielenClient = targetId; break;
                    case 'protect_neighbor': if(targetId) nightSummary.protections[targetId] = 'SCHUTZSCHILD_SIGRID'; break;
                    case 'protect_guest':
                        if (targetId) {
                            nightSummary.protections[targetId] = 'BORDELL_BAERBEL';
                            if (targetId === nightSummary.wwTarget && getPlayerData(targetId)?.roleKey === 'WERWOLF') {
                                actor.misc.baerbelSelfProtect = true;
                            }
                        }
                        break;
                    case 'reveal_role':
                         if (targetId) {
                            nightSummary.martinTarget = { targetId: targetId, actorId: actor.id };
                            if (getPlayerData(targetId)?.roleKey === 'Oeko_Sabine') {
                                nightSummary.martinSawSabine = true;
                                actor.misc.sawSabine = true;
                            }
                         }
                        break;
                    case 'use_potion':
                         if (targetId && action.subAction) {
                             if (action.subAction === 'protect') nightSummary.protections[targetId] = 'KRAEUTERHEXE_HILDE';
                             else if (action.subAction === 'block_ww') nightSummary.blocks.push(targetId);
                             else if (action.subAction === 'chaos') nightSummary.chaosTargets.push(targetId);
                         }
                         break;
                    case 'ask_dead':
                         const mediumName = action.medium; // Name statt ID
                         const livingTargetId = getPlayerByName(action.target)?.id; // ID des lebenden Ziels
                         if (livingTargetId && mediumName) {
                             const livingPlayer = getPlayerData(livingTargetId);
                             const isWolf = livingPlayer?.roleDetails.team === 'werwolf';
                             messages.push(`SL Info f√ºr Norbert (${actor.name}): Frage Geist ${mediumName} √ºber ${action.target}. Antwort: ${isWolf ? 'Werwolf (Daumen runter)' : 'Kein Werwolf (Daumen hoch)'}.`);
                         }
                         break;
                    case 'find_baerbel':
                         if (targetId) {
                             nightSummary.bauerTarget = { targetId: targetId, actorId: actor.id };
                             if (getPlayerData(targetId)?.roleKey === 'BORDELL_BAERBEL') {
                                 nightSummary.bauerFoundBaerbel = true;
                                 gameState.specialConditions.bauerFoundBaerbel = true;
                                 actor.misc.bauerProtectedThisNight = true;
                                 messages.push(`${actor.name} hat B√§rbel gefunden und ist diese Nacht gesch√ºtzt.`);
                             } else {
                                 messages.push(`SL Info f√ºr ${actor.name}: ${action.target} ist nicht B√§rbel.`);
                             }
                         }
                         break;
                    case 'sabine_actions': // Nur Schutz wird hier relevant
                         if (actor && actor.misc?.sabineRolledSix) { // Pr√ºfe den Status im Spielerobjekt
                             nightSummary.protections[actor.id] = 'Oeko_Sabine';
                             nightSummary.sabineProtected = true;
                         }
                         break;
                    case 'revive': if (targetId) nightSummary.revives.push(targetId); break;
                    case 'check_wolf':
                         if (targetId) {
                             const isWolf = getPlayerData(targetId)?.roleDetails.team === 'werwolf';
                             messages.push(`SL Info f√ºr Toni (${actor.name}): Pr√ºfung von ${action.target}. Ergebnis: ${isWolf ? 'Werwolf (Daumen runter)' : 'Kein Werwolf (Daumen hoch)'}.`);
                         }
                         break;
                    case 'guard_village': if (action.watches) nightSummary.wenzelWatched = true; break;
                    case 'find_wiebke':
                         if (targetId) {
                             nightSummary.fridaTarget = { targetId: targetId, actorId: actor.id };
                             const targetRole = getPlayerData(targetId)?.roleDetails;
                             const targetRoleKey = getPlayerData(targetId)?.roleKey;
                             if (targetRole && targetRole.team === 'werwolf') {
                                 nightSummary.fridaDied = true;
                                 messages.push(`Fisterin Frida (${actor.name}) hat einen Werwolf (${action.target}) ber√ºhrt und stirbt!`);
                             } else {
                                 const isWiebke = targetRoleKey === 'WUT_WIEBKE';
                                 messages.push(`SL Info f√ºr Frida (${actor.name}) √ºber ${action.target}: ${isWiebke ? 'Wut Wiebke gefunden!' : 'Nicht Wut Wiebke.'}`);
                             }
                         }
                         break;
                    case 'find_twink':
                         if (targetId) {
                             nightSummary.konnyTarget = { targetId: targetId, actorId: actor.id };
                             if (getPlayerData(targetId)?.roleKey === 'DER_TWINK') {
                                 nightSummary.twinkAbilityDeactivated = true;
                                 gameState.specialConditions.twinkDeactivated = true;
                                 messages.push(`Konversionstherapie Konny (${actor.name}) hat den Twink (${action.target}) gefunden! Seine F√§higkeit ist deaktiviert.`);
                             } else {
                                  messages.push(`SL Info f√ºr Konny (${actor.name}): ${action.target} ist nicht der Twink.`);
                             }
                         }
                         break;
                    case 'spread_rumor':
                         if (targetId && action.rumorText) {
                             nightSummary.rumors.push({ targetId: targetId, rumorText: action.rumorText });
                         }
                         break;
                    case 'link_three':
                         if (targets.length === 3) { nightSummary.linked = targets; nightSummary.linkedType = 'valentin'; }
                         break;
                    case 'link_two':
                         if (targets.length === 2) { nightSummary.linked = targets; nightSummary.linkedType = 'waltraud'; }
                         break;
                    case 'infect_roll':
                         if (targetId && action.infected) {
                             nightSummary.infections.push({ targetId: targetId, actorId: actor.id });
                         }
                         break;
                    case 'retten_oder_ausschalten':
                         if (action.subAction === 'retten' && targetId) nightSummary.heals.push(targetId);
                         else if (action.subAction === 'ausschalten' && targetId) nightSummary.ausschaltenTarget = { targetId: targetId, actorId: actor.id };
                         break;
                    case 'poison':
                         if (targetId) nightSummary.poisons.push({ targetId: targetId, actorId: actor.id });
                         break;
                    case 'visit_and_learn':
                         if (targetId) {
                             nightSummary.twinkVisitTarget = { targetId: targetId, actorId: actor.id };
                             const targetPlayer = getPlayerData(targetId);
                             if (targetPlayer?.roleKey === 'DER_GEILE_PRIESTER') {
                                 nightSummary.twinkKilledByPriest = true;
                                 messages.push(`Der Twink (${actor.name}) ist dem geilen Priester (${action.target}) begegnet und verschwindet!`);
                             } else {
                                 const isWolf = targetPlayer?.roleDetails.team === 'werwolf';
                                 messages.push(`SL Info f√ºr Twink (${actor.name}) √ºber ${action.target}: ${isWolf ? 'Werwolf!' : 'Kein Werwolf.'}`);
                             }
                         }
                         break;
                    case 'hunt_twink':
                         if (targetId) {
                             nightSummary.priestTarget = { targetId: targetId, actorId: actor.id };
                             if (getPlayerData(targetId)?.roleKey === 'DER_TWINK') {
                                 actor.misc.priesterProtectedThisNight = true;
                                 messages.push(`Der geile Priester (${actor.name}) hat den Twink (${action.target}) gefunden und ist diese Nacht gesch√ºtzt.`);
                                 // Twink Tod wird bei Twink-Aktion behandelt
                             } else {
                                  messages.push(`SL Info f√ºr Priester (${actor.name}): ${action.target} ist nicht der Twink.`);
                             }
                         }
                         break;
                }
            });

            // --- 2. Effekte anwenden und Todesf√§lle ermitteln ---
            let potentialDeaths = new Map(); // key: playerId, value: { causes: [], isProtectedBy: null }

            // Direkte Tode hinzuf√ºgen
            if (nightSummary.fridaDied) {
                 const fridaPlayer = gameState.players.find(p => p.roleKey === 'FISTERIN_FRIDA' && p.status === 'alive');
                 if(fridaPlayer) potentialDeaths.set(fridaPlayer.id, { causes: ['frida_fehler'], isProtectedBy: null });
            }
            if (nightSummary.twinkKilledByPriest) {
                 const twinkPlayer = gameState.players.find(p => p.roleKey === 'DER_TWINK' && p.status === 'alive');
                 if (twinkPlayer) potentialDeaths.set(twinkPlayer.id, { causes: ['twink_priester'], isProtectedBy: null });
            }

            // Angriffsziele hinzuf√ºgen (WW, Tanja)
            [nightSummary.wwTarget, nightSummary.ausschaltenTarget?.targetId].forEach((targetId, index) => {
                 if (targetId && getPlayerData(targetId)?.status === 'alive') {
                     const cause = index === 0 ? 'werwolf' : 'tanja_ausschalten';
                     if (!potentialDeaths.has(targetId)) {
                         potentialDeaths.set(targetId, { causes: [], isProtectedBy: null });
                     }
                     if (!potentialDeaths.get(targetId).causes.includes(cause)) {
                         potentialDeaths.get(targetId).causes.push(cause);
                     }
                 }
            });

            // Schutzmechanismen anwenden
            potentialDeaths.forEach((details, playerId) => {
                const player = getPlayerData(playerId);
                if (!player) return;

                let protectionSourceKey = null;
                if (nightSummary.protections[playerId]) protectionSourceKey = nightSummary.protections[playerId];
                if (nightSummary.heals.includes(playerId)) protectionSourceKey = 'TRIP_SITTERIN_TANJA'; // Tanja Rettung √ºberschreibt andere?
                if (player.misc?.baerbelSelfProtect) protectionSourceKey = 'BORDELL_BAERBEL';
                if (player.misc?.priesterProtectedThisNight) protectionSourceKey = 'DER_GEILE_PRIESTER';
                if (player.misc?.bauerProtectedThisNight) protectionSourceKey = 'BOY_BUTTER_BAEUERIN';
                if (nightSummary.wenzelWatched) protectionSourceKey = 'WACHMANN_WENZEL';

                // Hilde WW-Blockade (wirkt nur gegen WW-Angriff)
                if (details.causes.includes('werwolf')) {
                    const attackingWolves = getLivingPlayers('werwolf');
                    const activeAttackers = attackingWolves.filter(wolf => !nightSummary.blocks.includes(wolf.id));
                     if (activeAttackers.length === 0 && attackingWolves.length > 0) {
                        protectionSourceKey = 'KRAEUTERHEXE_HILDE'; // Alle WW blockiert
                    }
                    // Info √ºber blockierte W√∂lfe
                    attackingWolves.forEach(wolf => {
                        if (nightSummary.blocks.includes(wolf.id)) {
                             wolf.misc.blockWWActive = true;
                             messages.push(`${wolf.name} (Werwolf) wurde von der Hexe blockiert.`);
                        }
                    });
                }

                details.isProtectedBy = protectionSourceKey;
            });

            // Todesf√§lle basierend auf Schutz auswerten
            potentialDeaths.forEach((details, playerId) => {
                 const player = getPlayerData(playerId);
                 if (details.isProtectedBy) {
                     const protectorName = ROLES[details.isProtectedBy]?.name || details.isProtectedBy;
                     messages.push(`${player.name} wurde angegriffen (${details.causes.join('/')}), aber von ${protectorName} besch√ºtzt!`);
                     player.isProtected = true; // Markiere Spieler als gesch√ºtzt f√ºr die Icon-Anzeige
                 } else {
                     player.status = 'dead';
                     deathsThisNight.push(player);
                     messages.push(`${player.name} (${player.role}) ist gestorben!`); // Ursache weggelassen f√ºr Spielerinfo
                     logGameEvent(`${player.name} (${player.role}) ist gestorben! Ursache(n): ${details.causes.join(', ')}`);
                 }
            });

            // Gift setzen / Timer aktualisieren
            nightSummary.poisons.forEach(poisonData => {
                const targetPlayer = getPlayerData(poisonData.targetId);
                if (targetPlayer && targetPlayer.status === 'alive' && !targetPlayer.isPoisoned) {
                    targetPlayer.isPoisoned = true;
                    targetPlayer.poisonTimer = 2;
                    messages.push(`${targetPlayer.name} wurde von Gertrud vergiftet!`);
                }
            });
            gameState.players.forEach(p => {
                if (p.isPoisoned && p.poisonTimer > 0) {
                    p.poisonTimer--;
                    if (p.poisonTimer === 0 && p.status === 'alive') {
                        p.status = 'dead';
                        if (!deathsThisNight.some(dp => dp.id === p.id)) deathsThisNight.push(p);
                        messages.push(`${p.name} (${p.role}) ist an den Folgen des Gifts gestorben!`);
                        p.isPoisoned = false;
                    }
                }
            });

             // Infektionen durch Iltussy
            nightSummary.infections.forEach(infectionData => {
                const targetPlayer = getPlayerData(infectionData.targetId);
                if (targetPlayer && targetPlayer.status === 'alive' && targetPlayer.roleDetails.team === 'dorf') {
                    const oldRole = targetPlayer.role;
                    targetPlayer.roleDetails = ROLES.WERWOLF;
                    targetPlayer.role = ROLES.WERWOLF.name;
                    targetPlayer.roleKey = 'WERWOLF';
                    messages.push(`${targetPlayer.name} (ehemals ${oldRole}) wurde vom Iltis gebissen und ist nun ein Werwolf!`);
                    delete gameState.usedAbilities[targetPlayer.id]; targetPlayer.misc = {};
                }
            });

            // Verlinkungen setzen
            if (nightSummary.linked.length >= 2) {
                 const hasKonny = nightSummary.linked.some(id => getPlayerData(id)?.roleKey === 'KONVERSIONSTHERAPIE_KONNY');
                 const hasPriester = nightSummary.linked.some(id => getPlayerData(id)?.roleKey === 'DER_GEILE_PRIESTER');
                 if (hasKonny && hasPriester) {
                     messages.push(`Versuch, Konny & Priester zu ${nightSummary.linkedType === 'valentin' ? 'verkuppeln' : 'verweben'}, fehlgeschlagen.`);
                 } else {
                     gameState.specialConditions.linkedPlayers = nightSummary.linked;
                     const linkedNames = nightSummary.linked.map(id => getPlayerData(id)?.name).filter(Boolean).join(', ');
                     messages.push(`${linkedNames} sind nun durch ${nightSummary.linkedType === 'valentin' ? 'Liebe' : 'Schicksal'} verbunden!`);
                 }
            }
             // Kettentod durch Verlinkung pr√ºfen
             if (gameState.specialConditions.linkedPlayers.length > 0) {
                 const linkedGroup = gameState.specialConditions.linkedPlayers.map(id => getPlayerData(id)).filter(Boolean);
                 // Pr√ºfen, ob einer der *gerade eben* Verstorbenen Teil der Gruppe war
                 const anyLinkedDiedNow = deathsThisNight.some(deadPlayer => gameState.specialConditions.linkedPlayers.includes(deadPlayer.id));

                 if (anyLinkedDiedNow) {
                     linkedGroup.forEach(p => {
                         if (p.status === 'alive') { // Nur lebende Mitglieder sterben mit
                             p.status = 'dead';
                             if (!deathsThisNight.some(dp => dp.id === p.id)) deathsThisNight.push(p);
                             messages.push(`${p.name} (${p.role}) stirbt aus Kummer/Schicksal mit!`);
                         }
                     });
                     gameState.specialConditions.linkedPlayers = []; // Band ist gebrochen
                 }
             }

            // Dielenschleiferin-Kunde setzen
            const clientPlayer = getPlayerData(nightSummary.dielenClient);
            if (clientPlayer && clientPlayer.status === 'alive') {
                clientPlayer.clientForDielenschleiferin = true;
            }

            // Chaos-Trank-Effekt f√ºr den Tag markieren
            nightSummary.chaosTargets.forEach(targetId => {
                const targetPlayer = getPlayerData(targetId);
                if (targetPlayer && targetPlayer.status === 'alive') {
                    targetPlayer.misc.chaostrankActive = true;
                    messages.push(`${targetPlayer.name} wurde mit einem Chaostrank belegt.`);
                }
            });

            // Ger√ºchte f√ºr den Tag speichern
            nightSummary.rumors.forEach(rumor => {
                 const targetPlayer = getPlayerData(rumor.targetId);
                 if (targetPlayer && targetPlayer.status === 'alive') {
                     targetPlayer.misc.rumor = rumor.rumorText;
                     messages.push(`√úber ${targetPlayer.name} wird ein Ger√ºcht verbreitet.`);
                 }
            });

            // --- 3. Tagesereignis ausl√∂sen? ---
            gameState.specialConditions.activeEvent = null;
            dayEventAnnouncement.classList.add('hidden');
            if (gameState.specialConditions.eventsEnabled && gameState.day >= gameState.config.minEventDay && (gameState.day - gameState.specialConditions.lastEventDay >= gameState.config.minDaysBetweenEvents)) {
                if (Math.random() < gameState.config.eventProbability) {
                    const eventType = Math.random() < 0.5 ? 'Unwetter' : 'Pandemie';
                    gameState.specialConditions.activeEvent = { name: eventType };
                    gameState.specialConditions.lastEventDay = gameState.day;
                    logGameEvent(`Sonderereignis ausgel√∂st: ${eventType}`);
                    dayEventAnnouncement.classList.remove('hidden');
                    let eventText = "";
                    if (eventType === 'Unwetter') {
                        eventText = "Ein heftiges Unwetter zieht auf! Die heutige Diskussion wird auf 2 Minuten verk√ºrzt.";
                    } else { // Pandemie
                        const living = getLivingPlayers();
                        const maxAffected = Math.min(4, living.length);
                        const minAffected = Math.min(2, living.length);
                        const numAffected = Math.floor(Math.random() * (maxAffected - minAffected + 1)) + minAffected;
                        const affectedPlayers = living.sort(() => 0.5 - Math.random()).slice(0, numAffected);
                        gameState.specialConditions.activeEvent.affectedPlayers = affectedPlayers.map(p => p.id);
                        eventText = `Eine Pandemie grassiert! ${affectedPlayers.map(p=>p.name).join(', ')} sind infiziert und d√ºrfen heute nicht diskutieren (aber abstimmen).`;
                    }
                    dayEventDetails.textContent = eventText;
                    messages.push(`SONDEREIGNIS: ${eventText}`);
                }
            }

            // --- 4. Nachrichten und Status anzeigen ---
            dayEventsList.innerHTML = messages.filter(Boolean).map(msg => `<li>${msg}</li>`).join('');
            if (dayEventsList.innerHTML === '') {
                 dayEventsList.innerHTML = '<li>Die Nacht war bemerkenswert ereignislos.</li>';
            }
            if (deathsThisNight.length > 0) {
                 const deathLi = document.createElement('li');
                 deathLi.classList.add('font-semibold', 'text-red-400', 'mt-2', 'pt-2', 'border-t', 'border-gray-600');
                 deathLi.textContent = `Verstorben in dieser Nacht: ${deathsThisNight.map(p => `${p.name} (${p.role})`).join(', ')}`;
                 dayEventsList.appendChild(deathLi);
             }

            renderPlayerList(dayPlayerListStatus, gameState.players, false);
            dayCounter.textContent = gameState.day;
            showScreen('screen-day-results');

            // --- 5. Spielende pr√ºfen ---
            if (checkGameOver()) return;

            // --- 6. Wiederbelebte Spieler verarbeiten ---
            nightSummary.revives.forEach(targetId => {
                 const targetPlayer = getPlayerData(targetId);
                 if (targetPlayer && targetPlayer.status === 'dead') {
                     targetPlayer.status = 'alive';
                     targetPlayer.isPoisoned = false; targetPlayer.poisonTimer = 0;
                     targetPlayer.linkedTo = []; targetPlayer.clientForDielenschleiferin = false;
                     targetPlayer.misc = {};
                     const oldRole = targetPlayer.role;
                     // TODO: Logik f√ºr zuf√§llige neue Rolle implementieren
                     const newRoleKey = 'DORFBEWOHNER'; // Vereinfacht
                     targetPlayer.roleKey = newRoleKey;
                     targetPlayer.roleDetails = ROLES[newRoleKey];
                     targetPlayer.role = ROLES[newRoleKey].name;
                     delete gameState.usedAbilities[targetPlayer.id];
                     logGameEvent(`${targetPlayer.name} (ehemals ${oldRole}) wurde von Brunhilde wiederbelebt als ${targetPlayer.role}.`);
                     dayEventsList.innerHTML += `<li class="text-green-400">${targetPlayer.name} (ehemals ${oldRole}) wurde wiederbelebt als ${targetPlayer.role}!</li>`;
                     renderPlayerList(dayPlayerListStatus, gameState.players, false);
                 }
            });
             if (checkGameOver()) return; // Erneuter Check nach Wiederbelebung
        }


        function startDiscussion() {
            dayCounterVote.textContent = gameState.day;
            dayVoteRestrictions.textContent = '';

            // Timer Logik
            clearInterval(discussionTimerInterval);
            let timeRemaining = gameState.config.discussionTime;
            if (gameState.specialConditions.activeEvent?.name === 'Unwetter') {
                timeRemaining = gameState.config.unwetterTime;
            }
            dayVoteTimer.textContent = `Diskussionszeit: ${Math.floor(timeRemaining / 60)}:${(timeRemaining % 60).toString().padStart(2, '0')}`;

            discussionTimerInterval = setInterval(() => {
                timeRemaining--;
                dayVoteTimer.textContent = `Diskussionszeit: ${Math.floor(timeRemaining / 60)}:${(timeRemaining % 60).toString().padStart(2, '0')}`;
                if (timeRemaining <= 0) {
                    clearInterval(discussionTimerInterval);
                    dayVoteTimer.textContent = "Zeit abgelaufen!";
                }
            }, 1000);

            // Pandemie-Einschr√§nkungen
            let restrictedPlayers = [];
            if (gameState.specialConditions.activeEvent?.name === 'Pandemie') {
                restrictedPlayers = gameState.specialConditions.activeEvent.affectedPlayers || [];
                const affectedNames = restrictedPlayers.map(id => getPlayerData(id)?.name).filter(name => name);
                dayVoteRestrictions.textContent = `Pandemie: ${affectedNames.join(', ')} d√ºrfen nicht diskutieren!`;
            }

            // Beatrix Button
            const beatrix = gameState.players.find(p => p.status === 'alive' && p.roleKey === 'BLUTMAGIERIN_BEATRIX');
            const beatrixAbilityUses = getAbilityUses(beatrix?.id); // Gesamtnutzung
             if (beatrix && beatrixAbilityUses > 0) {
                 beatrixInterventionDiv.classList.remove('hidden');
                 btnBeatrixIntervene.disabled = true; // Erst aktivieren, wenn Ziel gew√§hlt
                 beatrixResultSpan.textContent = '';
             } else {
                 beatrixInterventionDiv.classList.add('hidden');
             }

            renderPlayerList(dayVoteList, getLivingPlayers(), true, 'lynch');
            btnConfirmLynch.disabled = true;
            lynchSelectionInfo.textContent = 'W√§hle einen Spieler f√ºr die Lynchung aus.';
            showScreen('screen-day-vote');

            // Ger√ºchte / Chaos anzeigen
            getLivingPlayers().forEach(p => {
                if (p.misc.rumor) {
                    const rumorLi = document.createElement('li');
                    rumorLi.classList.add('bg-yellow-900', 'border', 'border-yellow-700', 'text-yellow-300');
                    rumorLi.innerHTML = `<span class="icon icon-megaphone">üì¢</span> ${p.name} muss folgendes Ger√ºcht vorlesen: "${p.misc.rumor}"`;
                    dayVoteList.prepend(rumorLi);
                    delete p.misc.rumor;
                }
                 if (p.misc.chaostrankActive) {
                     const chaosLi = document.createElement('li');
                     chaosLi.classList.add('bg-purple-900', 'border', 'border-purple-700', 'text-purple-300');
                     chaosLi.innerHTML = `<span class="icon icon-potion">ü§™</span> ${p.name} steht unter dem Einfluss des Chaos-Tranks! (SL: Anweisen)`;
                     dayVoteList.prepend(chaosLi);
                     delete p.misc.chaostrankActive;
                 }
            });
        }

        function handleBeatrixIntervention() {
             const beatrix = gameState.players.find(p => p.status === 'alive' && p.roleKey === 'BLUTMAGIERIN_BEATRIX');
             if (!beatrix || getAbilityUses(beatrix.id) <= 0 || !gameState.lynchTarget) {
                 return;
             }

             const roll = Math.floor(Math.random() * 6) + 1;
             const targetPlayerName = gameState.lynchTarget;
             let message = `Beatrix wirkt ihren Zauber auf ${targetPlayerName}! W√ºrfel: ${roll}. `;
             let saved = false;

             if (roll >= 4) {
                 message += `Gerettet!`;
                 saved = true;
                 beatrixResultSpan.classList.add('text-green-400');
                 beatrixResultSpan.classList.remove('text-red-400');
             } else {
                 message += `Kein Erfolg.`;
                 saved = false;
                  beatrixResultSpan.classList.add('text-red-400');
                 beatrixResultSpan.classList.remove('text-green-400');
             }
             beatrixResultSpan.textContent = message;
             logGameEvent(message);

             markAbilityUsed(beatrix.id); // F√§higkeit als genutzt markieren
             btnBeatrixIntervene.disabled = true;

             if (saved) {
                 btnConfirmLynch.disabled = true;
                 lynchSelectionInfo.textContent = `${targetPlayerName} wurde von Beatrix gerettet!`;
                  setTimeout(() => {
                     if (checkGameOver()) return;
                     startNightPhase();
                 }, 3000);
             }
        }


        function confirmLynch() {
            clearInterval(discussionTimerInterval);
            if (!gameState.lynchTarget) return;

            const targetPlayer = getPlayerByName(gameState.lynchTarget);
            if (!targetPlayer) return;

            // Pr√ºfen ob Beatrix eingegriffen und gerettet hat
             if (beatrixResultSpan.textContent.includes("Gerettet")) {
                 logGameEvent(`Lynchversuch auf ${targetPlayer.name} durch Beatrix verhindert.`);
                 if (checkGameOver()) return;
                 startNightPhase();
                 return;
             }

            targetPlayer.status = 'dead';
            logGameEvent(`${targetPlayer.name} wird gelyncht.`);
            lynchResultText.textContent = `Das Dorf hat entschieden: ${targetPlayer.name} wird gelyncht!`;
            lynchRoleReveal.textContent = `${targetPlayer.name} war... ${targetPlayer.role}!`;

            lynchConsequences.innerHTML = '';

            // --- Kettenreaktionen durch Lynchung ---
            // Dielenschleiferin
            if (targetPlayer.clientForDielenschleiferin) {
                const dielenSchleiferin = gameState.players.find(p => p.roleKey === 'DIELENSCHLEIFERIN' && p.status === 'alive');
                if (dielenSchleiferin) {
                    dielenSchleiferin.status = 'dead';
                    lynchConsequences.innerHTML += `<li>Da ${targetPlayer.name} ihr Kunde war, stirbt auch die Dielenschleiferin (${dielenSchleiferin.name})!</li>`;
                    logGameEvent(`Dielenschleiferin ${dielenSchleiferin.name} stirbt mit Kunde ${targetPlayer.name}.`);
                }
            }

            // Verliebte / Verwobene
            if (gameState.specialConditions.linkedPlayers?.includes(targetPlayer.id)) {
                 const linkedPlayers = gameState.specialConditions.linkedPlayers.map(id => getPlayerData(id));
                 linkedPlayers.forEach(p => {
                        if (p && p.status === 'alive' && p.id !== targetPlayer.id) {
                            p.status = 'dead';
                            lynchConsequences.innerHTML += `<li>${p.name} (${p.role}) stirbt aus Kummer/Schicksal mit ${targetPlayer.name}!</li>`;
                            logGameEvent(`${p.name} stirbt wegen Verbindung zu ${targetPlayer.name}.`);
                        }
                    });
                 gameState.specialConditions.linkedPlayers = [];
            }

            // Martin/Sabine
             const martinPlayer = gameState.players.find(p => p.roleKey === 'MANSPLAINING_MARTIN' && p.status === 'alive');
             if (martinPlayer && targetPlayer.roleKey === 'Oeko_Sabine' && martinPlayer.misc.sawSabine) {
                 martinPlayer.status = 'dead';
                 lynchConsequences.innerHTML += `<li>Da √ñko Sabine stirbt, stirbt Mansplaining Martin (${martinPlayer.name}) an gebrochenem Stolz mit!</li>`;
                 logGameEvent(`Mansplaining Martin stirbt mit √ñko Sabine.`);
             }

            renderPlayerList(lynchPlayerListStatus, gameState.players, false);
            showScreen('screen-lynch-result');

            // Nach Lynchung auf Spielende pr√ºfen
             if (checkGameOver()) return;

             // Pr√ºfen ob Susie gewonnen hat (nur Tag 1)
             if (gameState.day === 1 && targetPlayer.roleKey === 'SUIZID_SUSIE') {
                 logGameEvent("Suizid Susie wurde am ersten Tag gelyncht!");
                 endGame('susie', [targetPlayer]);
                 return; // Spiel endet hier
             }


            // Reset f√ºr den n√§chsten Tag/Nacht
            gameState.lynchTarget = null;
            beatrixResultSpan.textContent = '';
        }


        // --- Spielende Logik ---
        function checkGameOver() {
            const livingPlayers = gameState.players.filter(p => p.status === 'alive');
            if (livingPlayers.length === 0) { // Niemand lebt mehr
                logGameEvent("Spielende! Niemand hat √ºberlebt.");
                endGame('niemand', []);
                return true;
            }

            const livingWolves = livingPlayers.filter(p => p.roleDetails.team === 'werwolf');
            const livingDorf = livingPlayers.filter(p => p.roleDetails.team === 'dorf' || p.roleDetails.winCondition === 'dorf_wins');
            const livingWiebke = livingPlayers.find(p => p.roleKey === 'WUT_WIEBKE');

            let gameOver = false;
            let winner = null;
            let winners = [];

            // 1. Susie Sieg wurde bereits in confirmLynch() behandelt

            // 2. Wiebke Sieg
            if (livingWiebke && livingPlayers.length === 1) {
                gameOver = true; winner = 'wiebke'; winners = [livingWiebke];
            }

            // 3. Werwolf Sieg
            const livingNonWolvesNonWiebke = livingPlayers.filter(p => p.roleDetails.team !== 'werwolf' && p.roleKey !== 'WUT_WIEBKE');
            if (!gameOver && livingWolves.length > 0 && livingWolves.length >= livingNonWolvesNonWiebke.length) {
                 gameOver = true; winner = 'werwolf'; winners = livingWolves;
            }

            // 4. Dorfsieg
            if (!gameOver && livingWolves.length === 0 && !livingWiebke) {
                gameOver = true; winner = 'dorf'; winners = livingDorf;
            }

            if (gameOver) {
                logGameEvent(`Spielende! Gewinner: ${winner}.`);
                endGame(winner, winners);
                return true;
            }
            return false;
        }

        function endGame(winnerTeam, winnerPlayers) {
            let message = "";
            switch (winnerTeam) {
                case 'dorf': message = "Die Werw√∂lfe wurden besiegt! Das Dorf hat gewonnen!"; break;
                case 'werwolf': message = "Die Werw√∂lfe haben die Oberhand gewonnen!"; break;
                case 'susie': message = `${winnerPlayers[0]?.name || 'Suizid Susie'} hat das Spiel gewonnen, indem er/sie am ersten Tag gelyncht wurde!`; break;
                case 'wiebke': message = `${winnerPlayers[0]?.name || 'Wut Wiebke'} hat alle anderen √ºberlebt und gewinnt alleine!`; break;
                case 'niemand': message = "Niemand hat √ºberlebt!"; break;
                default: message = "Das Spiel ist vorbei!";
            }
            gameOverMessage.textContent = message;

            winnersList.innerHTML = '';
            const winningPlayersToShow = gameState.players.filter(p => {
                 // Zeige alle, die zum Siegerteam geh√∂ren, egal ob lebend oder tot, au√üer bei Einzelsiegern
                 switch (winnerTeam) {
                     case 'dorf': return p.roleDetails.team === 'dorf' || p.roleDetails.winCondition === 'dorf_wins';
                     case 'werwolf': return p.roleDetails.team === 'werwolf';
                     case 'susie': return p.roleKey === 'SUIZID_SUSIE';
                     case 'wiebke': return p.roleKey === 'WUT_WIEBKE';
                     default: return false;
                 }
             });

             if (winningPlayersToShow.length > 0) {
                 winningPlayersToShow.forEach(p => {
                     const li = document.createElement('li');
                     li.textContent = `${p.name} (${p.role}) ${p.status === 'dead' ? ' (Verstorben)' : ''}`;
                     winnersList.appendChild(li);
                 });
             } else if (winnerTeam === 'niemand') {
                  winnersList.innerHTML = `<li>Keine √úberlebenden.</li>`;
             } else {
                 winnersList.innerHTML = `<li>Keine Gewinner konnten ermittelt werden.</li>`; // Fallback
             }

            showScreen('screen-game-over');
        }

        // --- Hilfsfunktionen f√ºr Rollenlogik ---
        function getNeighbors(playerId) {
            const playerIndex = gameState.players.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return [];

            const livingPlayers = getLivingPlayers();
            if (livingPlayers.length < 2) return [];

            // Finde die Indizes der lebenden Spieler in der urspr√ºnglichen Reihenfolge
            const livingIndices = gameState.players.map((p, index) => p.status === 'alive' ? index : -1).filter(index => index !== -1);
            const currentLivingIndex = livingIndices.indexOf(playerIndex);

            if (currentLivingIndex === -1 || livingIndices.length < 2) return []; // Spieler nicht lebend oder zu wenige lebende Spieler

            const numLiving = livingIndices.length;
            const leftOriginalIndex = livingIndices[(currentLivingIndex - 1 + numLiving) % numLiving];
            const rightOriginalIndex = livingIndices[(currentLivingIndex + 1) % numLiving];

            const neighbors = [];
            if (gameState.players[leftOriginalIndex]) neighbors.push(gameState.players[leftOriginalIndex]);
            if (gameState.players[rightOriginalIndex] && rightOriginalIndex !== leftOriginalIndex) {
                 neighbors.push(gameState.players[rightOriginalIndex]);
            }

            return neighbors;
        }

        function getSabineTargets() {
            const wolves = getLivingPlayers('werwolf');
            const nonWolves = getLivingPlayers().filter(p => p.roleDetails.team !== 'werwolf' && p.roleKey !== 'Oeko_Sabine');
            if (wolves.length === 0) return [];

            const targetWolf = wolves[Math.floor(Math.random() * wolves.length)];
            let otherTargets = nonWolves.sort(() => 0.5 - Math.random());

            const targets = [targetWolf];
            targets.push(...otherTargets.slice(0, 2)); // Nimm bis zu 2 Nicht-W√∂lfe

            // Wenn weniger als 3 Ziele, f√ºlle mit anderen W√∂lfen auf (falls vorhanden)
            if (targets.length < 3) {
                const otherWolves = wolves.filter(w => w.id !== targetWolf.id);
                targets.push(...otherWolves.slice(0, 3 - targets.length));
            }
             // Wenn immer noch weniger als 3 Ziele (sehr kleine Runden), f√ºlle mit Sabine selbst? (Regeln unklar)

            return targets.sort(() => Math.random() - 0.5); // Reihenfolge mischen
        }


        // --- Event Listener ---
        // Event Listener werden nach dem Laden des DOM hinzugef√ºgt
        function addEventListeners() {
            btnGoToRoleAssignment.addEventListener('click', saveNamesAndGoToRoles); // Ge√§nderte Funktion
            btnStartGame.addEventListener('click', validateAndStartGame);
            btnEventsYes.addEventListener('click', () => setupEvents(true));
            btnEventsNo.addEventListener('click', () => setupEvents(false));
            btnNextAction.addEventListener('click', defaultNextActionButtonLogic);
            btnStartDiscussion.addEventListener('click', startDiscussion);
            btnConfirmLynch.addEventListener('click', confirmLynch);
            // Stelle sicher, dass der Button existiert, bevor der Listener hinzugef√ºgt wird
            if (btnBeatrixIntervene) {
                btnBeatrixIntervene.addEventListener('click', handleBeatrixIntervention);
            } else {
                console.warn("Button btnBeatrixIntervene not found during initialization.");
            }
            btnStartNextNight.addEventListener('click', () => {
                 if (checkGameOver()) return;
                 startNightPhase();
            });
            btnNewGame.addEventListener('click', () => {
                // Vollst√§ndiger Reset
                gameState = {
                    players: [], playerCount: 0, currentScreen: 'screen-setup-players',
                    night: 0, day: 0, currentRoleIndex: -1, rolesActingTonight: [],
                    nightActions: [], lynchTarget: null, gameLog: [], usedAbilities: {},
                    specialConditions: { linkedPlayers: [], twinkDeactivated: false, bauerFoundBaerbel: false, eventsEnabled: false, lastEventDay: 0, activeEvent: null },
                    config: gameState.config // Konfiguration beibehalten
                };
                clearInterval(discussionTimerInterval);
                // Clear UI elements
                if(playerNameInputsContainer) playerNameInputsContainer.innerHTML = '';
                if(playerRoleAssignmentContainer) playerRoleAssignmentContainer.innerHTML = '';
                if(nightPlayerList) nightPlayerList.innerHTML = '';
                if(dayEventsList) dayEventsList.innerHTML = '';
                if(dayPlayerListStatus) dayPlayerListStatus.innerHTML = '';
                if(dayVoteList) dayVoteList.innerHTML = '';
                if(lynchPlayerListStatus) lynchPlayerListStatus.innerHTML = '';
                if(winnersList) winnersList.innerHTML = '';
                // Reset error messages and special UI
                if(roleAssignmentError) roleAssignmentError.classList.add('hidden');
                if(nightSpecialUI) nightSpecialUI.innerHTML = '';
                if(selectionInfo) selectionInfo.textContent = '';
                if(lynchSelectionInfo) lynchSelectionInfo.textContent = '';
                if(beatrixResultSpan) beatrixResultSpan.textContent = '';
                if(beatrixInterventionDiv) beatrixInterventionDiv.classList.add('hidden');
                if(dayEventAnnouncement) dayEventAnnouncement.classList.add('hidden');

                setupPlayerCountButtons();
                showScreen('screen-setup-players');
            });
        }

        // --- Initialisierung ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed");
            initializeDOMElements(); // DOM-Elemente initialisieren
            addEventListeners(); // Event Listener hinzuf√ºgen
            setupPlayerCountButtons(); // Spieleranzahl-Buttons erstellen
            showScreen('screen-setup-players'); // Startbildschirm anzeigen
        });

    </script>

</body>
</html>
```

**√Ñnderungen:**

1.  **`saveNamesAndGoToRoles()` Funktion:** Eine neue Funktion wurde eingef√ºhrt. Sie wird aufgerufen, wenn der Button "Weiter zur Rollenverteilung" geklickt wird. Diese Funktion liest die Namen aus den Input-Feldern (`player-name-i`) aus, speichert sie in `gameState.players[i].name` und ruft *danach* `setupRoleAssignment()` auf.
2.  **Event Listener f√ºr `btnGoToRoleAssignment`:** Der Event Listener f√ºr diesen Button ruft jetzt `saveNamesAndGoToRoles()` auf statt direkt `setupRoleAssignment()`.
3.  **`setupRoleAssignment()` Anpassung:** Diese Funktion liest die Namen jetzt direkt aus dem `gameState.players`-Array, das zuvor von `saveNamesAndGoToRoles()` aktualisiert wurde. Es wird auch gepr√ºft, ob die Spieleranzahl im `gameState` mit der erwarteten Anzahl √ºbereinstimmt, um Fehler abzufangen.
4.  **DOM Element Initialisierung:** Die Zuweisung der DOM-Elemente zu JavaScript-Variablen wurde in eine eigene Funktion `initializeDOMElements()` ausgelagert und wird nun sicher innerhalb von `DOMContentLoaded` aufgerufen, bevor die Event Listener hinzugef√ºgt werden. Dies stellt sicher, dass alle Elemente verf√ºgbar sind, wenn die Skripte darauf zugreifen.
5.  **Diverse Checks:** Zus√§tzliche Pr√ºfungen wurden eingebaut, um sicherzustellen, dass auf Elemente und Daten zugegriffen wird, die auch existieren, um Laufzeitfehler zu vermeiden.

Bitte probiere diese Version aus. Der Screen "Rollen verteilen" sollte jetzt korrekt die zuvor eingegebenen Spielernamen anzeigen und f√ºr jeden Spieler ein Dropdown zur Rollenauswahl bereitstellen. Der Button "Spiel starten" sollte dann die Validierung und den Start der n√§chsten Phase ausl√∂s
