<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Werwolf Deluxe - Spielleiter App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a; /* Dunkler Hintergrund */
            color: #e0e0e0; /* Heller Text */
        }
        .screen {
            display: none; /* Alle Screens standardm√§√üig ausblenden */
            padding: 2rem;
            border: 1px solid #444;
            border-radius: 8px;
            background-color: #2a2a2a; /* Etwas hellerer Hintergrund f√ºr Screens */
            margin-top: 1rem;
            min-height: 450px; /* Etwas h√∂her f√ºr mehr Inhalt */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .screen.active {
            display: flex; /* Aktiven Screen anzeigen */
        }
        button, input[type="text"], select {
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            border: 1px solid #555; /* Leichter Rand f√ºr bessere Sichtbarkeit */
            margin: 0.5rem 0.5rem 0.5rem 0;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
            background-color: #4a5568; /* Standard Grau f√ºr Inputs/Selects */
            color: #e0e0e0;
        }
        button {
            background-color: #5a67d8; /* Indigo */
            color: white;
            border: none;
        }
        button:hover:not(:disabled) {
            background-color: #434190;
        }
        button:disabled {
            background-color: #3a3a3a;
            color: #777;
            cursor: not-allowed;
        }
        button.secondary {
            background-color: #4a5568; /* Grau */
        }
        button.secondary:hover:not(:disabled) {
            background-color: #2d3748;
        }
        button.danger {
            background-color: #e53e3e; /* Rot */
        }
        button.danger:hover:not(:disabled) {
            background-color: #c53030;
        }
        input[type="text"], select {
            background-color: #3a3a3a; /* Dunkleres Grau f√ºr Inputs/Selects */
        }
        select {
             appearance: none; /* Standard-Pfeil entfernen */
             background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23BBB%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.6-3.6%205.4-7.9%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
             background-repeat: no-repeat;
             background-position: right 0.7rem top 50%;
             background-size: 0.65rem auto;
             padding-right: 2.5rem; /* Platz f√ºr den Pfeil */
        }
        h1, h2, h3 {
            color: #ffffff;
            margin-bottom: 1rem;
        }
        ul {
            list-style: none;
            padding: 0;
            margin: 0; /* Standard-Margin entfernen */
        }
        li {
            background-color: #3a3a3a;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; /* Erlaubt Umbruch bei kleinen Bildschirmen */
        }
        .player-info {
            flex-grow: 1;
            margin-right: 1rem; /* Abstand zu den Buttons */
        }
        .player-actions {
            flex-shrink: 0; /* Verhindert, dass Buttons schrumpfen */
        }
        .player-actions button, .player-actions select {
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }
        .role-info {
            font-size: 0.9em;
            color: #a0aec0;
            display: block; /* Sorgt f√ºr Zeilenumbruch unter dem Namen */
        }
        .status-alive { color: #68d391; } /* Gr√ºn */
        .status-dead { color: #fc8181; text-decoration: line-through; opacity: 0.6; } /* Rot und durchgestrichen */
        .selected {
            outline: 2px solid #63b3ed; /* Blauer Rand f√ºr Auswahl */
            outline-offset: 2px;
        }
        .icon { display: inline-block; margin-left: 5px; font-size: 0.9em; }
        .icon-heart { color: #e53e3e; } /* Rot */
        .icon-shield { color: #63b3ed; } /* Blau */
        .icon-skull { color: #a0aec0; } /* Grau */
        .icon-potion { color: #9f7aea; } /* Lila */
        .icon-eye { color: #4fd1c5; } /* T√ºrkis */
        .icon-question { color: #f6e05e; } /* Gelb */
        .icon-moon { color: #f6e05e; } /* Gelb */
        .icon-sun { color: #f6ad55; } /* Orange */
        .icon-poison { color: #48bb78; } /* Gr√ºn f√ºr Gift */
        .icon-cross { color: #e53e3e; } /* Rot f√ºr Blockade/Tod */
        .icon-hand { color: #ed8936; } /* Orange f√ºr Fisterin */
        .icon-wand { color: #d53f8c; } /* Pink f√ºr Magie */
        .icon-mask { color: #a0aec0; } /* Grau f√ºr Travestie */
        .icon-tools { color: #a0aec0; } /* Grau f√ºr Dielenschleiferin */
        .icon-megaphone { color: #f6e05e; } /* Gelb f√ºr K√§the */
        .icon-zombie { color: #9f7aea; } /* Lila f√ºr Nekromant */
        .icon-first-aid { color: #68d391; } /* Gr√ºn f√ºr Brunhilde */
        .icon-magnifying-glass { color: #4fd1c5; } /* T√ºrkis f√ºr Suche */
        .icon-warning { color: #f56565; } /* Rot f√ºr Warnung/Fehler */

        .hidden { display: none; }
        .error-message { color: #f56565; font-size: 0.9em; margin-top: 5px; }
        .player-list-container { max-height: 300px; overflow-y: auto; margin-bottom: 1rem; } /* Scrollbarer Bereich */
    </style>
</head>
<body class="p-4 md:p-8">

    <h1 class="text-3xl font-bold text-center mb-6">Werwolf Deluxe - Spielleiter App</h1>

    <div id="screen-setup-players" class="screen active">
        <div>
            <h2 class="text-2xl mb-4">Spiel einrichten: Spieleranzahl</h2>
            <p class="mb-4">Wie viele Spieler ziehen in unser kleines charmantes Dorf?</p>
            <div id="player-count-buttons" class="flex flex-wrap gap-2">
                </div>
        </div>
        <div>
            <p class="text-sm text-gray-400 mt-4">W√§hle die Anzahl der Spieler (8-15).</p>
        </div>
    </div>

    <div id="screen-setup-names" class="screen">
        <div>
            <h2 class="text-2xl mb-4">Spieler benennen</h2>
            <p class="mb-4">Bitte gib die Namen der Spieler ein:</p>
            <div id="player-name-inputs" class="space-y-2 player-list-container">
                </div>
        </div>
        <div>
            <button id="btn-go-to-role-assignment">Weiter zur Rollenverteilung</button>
        </div>
    </div>

    <div id="screen-setup-roles" class="screen">
        <div>
            <h2 class="text-2xl mb-4">Rollen verteilen</h2>
            <p class="mb-4">Bitte weise jedem Spieler seine gezogene Rolle zu:</p>
            <div id="player-role-assignment" class="space-y-2 player-list-container">
                </div>
            <p id="role-assignment-error" class="error-message hidden"></p>
        </div>
        <div>
             <p class="text-sm text-gray-400 mb-2">Stelle sicher, dass die Anzahl der Werw√∂lfe stimmt und keine inkompatiblen Rollen gew√§hlt wurden.</p>
            <button id="btn-start-game">Spiel starten</button>
        </div>
    </div>

    <div id="screen-night" class="screen">
        <div>
            <h2 class="text-2xl mb-4"><span class="icon icon-moon">üåô</span> Nacht <span id="night-counter">1</span></h2>
            <h3 id="night-role-action" class="text-xl mb-4">Warte auf n√§chste Aktion...</h3>
            <p id="night-instruction" class="mb-4"></p>
            <div id="night-special-ui" class="mb-4 space-y-2">
                </div>
            <p class="mb-2 font-semibold">Spielerliste:</p>
            <ul id="night-player-list" class="player-list-container">
                </ul>
        </div>
        <div>
            <p id="selection-info" class="text-sm text-gray-400 mb-2 h-4"></p> <button id="btn-next-action" class="w-full">Aktion best√§tigen / N√§chster Schritt</button>
        </div>
    </div>

    <div id="screen-day-results" class="screen">
        <div>
            <h2 class="text-2xl mb-4"><span class="icon icon-sun">‚òÄÔ∏è</span> Tag <span id="day-counter">1</span> - Was ist passiert?</h2>
            <p class="mb-4">Die Nacht war unruhig. Folgendes ist geschehen:</p>
            <ul id="day-events-list" class="mb-4 player-list-container">
                </ul>
             <div id="day-event-announcement" class="mb-4 p-3 bg-yellow-900 border border-yellow-700 rounded hidden">
                <h3 class="font-semibold text-yellow-300">Sonderereignis!</h3>
                <p id="day-event-details"></p>
            </div>
            <p class="mb-2 font-semibold">Aktueller Spielerstatus:</p>
            <ul id="day-player-list-status" class="player-list-container">
                </ul>
        </div>
        <div>
             <button id="btn-start-discussion" class="w-full">Diskussion beginnen</button>
        </div>
    </div>

    <div id="screen-day-vote" class="screen">
         <div>
            <h2 class="text-2xl mb-4"><span class="icon icon-sun">‚òÄÔ∏è</span> Tag <span id="day-counter-vote">1</span> - Diskussion & Lynchung</h2>
            <p class="mb-2">Das Dorf diskutiert und stimmt ab, wer gelyncht werden soll.</p>
            <p id="day-vote-timer" class="mb-2 font-semibold text-yellow-400"></p>
            <p id="day-vote-restrictions" class="mb-4 text-orange-400"></p>
            <p class="mb-2 font-semibold">W√§hlt den Spieler aus, der gelyncht werden soll:</p>
            <ul id="day-vote-list" class="player-list-container">
                </ul>
         </div>
         <div>
            <p id="lynch-selection-info" class="text-sm text-gray-400 mb-2 h-4"></p>
            <div id="beatrix-intervention" class="hidden mb-2">
                 <button id="btn-beatrix-intervene" class="secondary">Blutmagierin Beatrix eingreifen lassen?</button>
                 <span id="beatrix-result" class="ml-2"></span>
            </div>
            <button id="btn-confirm-lynch" class="w-full" disabled>Lynchmord best√§tigen</button>
         </div>
    </div>

     <div id="screen-lynch-result" class="screen">
        <div>
            <h2 class="text-2xl mb-4"><span class="icon icon-skull">üíÄ</span> Lynch-Ergebnis</h2>
            <p id="lynch-result-text" class="mb-4 text-xl"></p>
            <p id="lynch-role-reveal" class="mb-4 font-semibold text-lg"></p>
            <div id="lynch-consequences" class="mb-4 text-red-400 space-y-1">
                </div>
             <p class="mb-2 font-semibold">Verbleibende Spieler:</p>
            <ul id="lynch-player-list-status" class="player-list-container">
                </ul>
        </div>
        <div>
            <button id="btn-start-next-night" class="w-full">N√§chste Nacht beginnen</button>
        </div>
    </div>

    <div id="screen-game-over" class="screen">
        <div>
            <h2 class="text-2xl mb-4">Spielende!</h2>
            <p id="game-over-message" class="text-xl font-semibold mb-4"></p>
            <p class="mb-2">Die Gewinner sind:</p>
            <ul id="winners-list" class="mb-4">
                </ul>
        </div>
        <div>
            <button id="btn-new-game" class="w-full">Neues Spiel starten</button>
        </div>
    </div>

    <div id="screen-setup-events" class="screen">
        <div>
            <h2 class="text-2xl mb-4">Sonderereignisse</h2>
            <p class="mb-4">Sollen die zuf√§lligen Tagesereignisse "Unwetter" und "Pandemie" im Spiel vorkommen k√∂nnen?</p>
            <p class="text-sm text-gray-400 mb-4">(Sie k√∂nnen fr√ºhestens ab Tag 3 mit 20% Wahrscheinlichkeit auftreten.)</p>
        </div>
        <div>
            <button id="btn-events-yes">Ja, Ereignisse aktivieren</button>
            <button id="btn-events-no" class="secondary">Nein, ohne Ereignisse spielen</button>
        </div>
    </div>


    <script>
        // --- Globale Variablen und Spielzustand ---
        let gameState = {
            players: [], // { id, name, role, roleKey, roleDetails, status: 'alive'/'dead', isProtected, isPoisoned, poisonTimer, linkedTo: [], clientForDielenschleiferin, misc: {} }
            playerCount: 0,
            currentScreen: 'screen-setup-players',
            night: 0,
            day: 0,
            currentRoleIndex: -1, // Index in der `rolesActingTonight` Liste
            rolesActingTonight: [], // Die Rollen, die in der aktuellen Nacht tats√§chlich agieren
            nightActions: [], // Gespeicherte Aktionen der Nacht
            lynchTarget: null, // Name des Spielers
            gameLog: [],
            usedAbilities: {}, // Z√§hlt Nutzung einmaliger F√§higkeiten, z.B. { 'player-3_heal': 1, 'player-5_protect': 1 }
            specialConditions: {
                linkedPlayers: [], // Array von Spieler-IDs
                twinkDeactivated: false,
                bauerFoundBaerbel: false,
                eventsEnabled: false,
                lastEventDay: 0, // Um Abstand zwischen Events zu sichern
                activeEvent: null, // { name: 'Pandemie', affectedPlayers: [id1, id2...] }
            },
            config: {
                werwolfCount: { 8: 2, 9: 2, 10: 3, 11: 3, 12: 3, 13: 4, 14: 4, 15: 4 },
                eventProbability: 0.20, // 20% Chance f√ºr ein Event pro Tag (ab Tag 3)
                minEventDay: 3,
                minDaysBetweenEvents: 2,
                discussionTime: 7 * 60, // 7 Minuten in Sekunden
                unwetterTime: 2 * 60, // 2 Minuten in Sekunden
            }
        };

        // --- Rollendefinitionen (komplett, basierend auf CSV/Doc) ---
        // Schl√ºssel sind eindeutig und werden intern verwendet
        const ROLES = {
            // Dorfbewohner Neutral
            DORFBEWOHNER: { name: 'Dorfbewohner/in', team: 'dorf', nightAction: false },
            DIELENSCHLEIFERIN: { name: 'Dielenschleiferin', team: 'dorf', nightAction: true, actionType: 'choose_client', order: 90 },
            HEIMSCHEISSERIN: { name: 'Heimschei√üerin', team: 'dorf', nightAction: true, actionType: 'observe_passive', order: 11 }, // Passiv w√§hrend WW
            PROKRASTINATIONS_PAULA: { name: 'Prokrastinations Paula', team: 'dorf', nightAction: false, special: 'getsNewRoleOnNight2' },
            SCHUTZSCHILD_SIGRID: { name: 'Schutzschild-Sigrid', team: 'dorf', nightAction: true, actionType: 'protect_neighbor', uses: 1, order: 41 },

            // Dorfbewohner mit F√§higkeiten
            BORDELL_BAERBEL: { name: 'Bordell B√§rbel', team: 'dorf', nightAction: true, actionType: 'protect_guest', order: 40 },
            MANSPLAINING_MARTIN: { name: 'Mansplaining Martin', team: 'dorf', nightAction: true, actionType: 'reveal_role', order: 70, special: 'sabine_interaction' },
            KRAEUTERHEXE_HILDE: { name: 'Kr√§uterhexe Hilde', team: 'dorf', nightAction: true, actionType: 'use_potion', uses: { protect: 1, block_ww: 1, chaos: 1 }, order: 35 },
            NEKROMANT_NORBERT: { name: 'Nekromant Norbert', team: 'dorf', nightAction: true, actionType: 'ask_dead', uses: 1, order: 75, condition: 'player_is_dead' },
            BOY_BUTTER_BAEUERIN: { name: 'Boy-Butter B√§uerin', team: 'dorf', nightAction: true, actionType: 'find_baerbel', order: 65, condition: 'baerbel_not_found' },
            Oeko_Sabine: { name: '√ñko Sabine', team: 'dorf', nightAction: true, actionType: 'sabine_actions', order: 15, special: 'sabine_interaction' }, // Kombiniert Info & Schutz
            BESTATTERIN_BRUNHILDE: { name: 'Bestatterin Brunhilde', team: 'dorf', nightAction: true, actionType: 'revive', uses: 1, order: 80, condition: 'player_is_dead' },
            TUERSTEHER_TONI: { name: 'Nicht-bin√§re T√ºrsteherperson Toni', team: 'dorf', nightAction: true, actionType: 'check_wolf', order: 50 },
            WACHMANN_WENZEL: { name: 'Wachmann Wenzel', team: 'dorf', nightAction: true, actionType: 'guard_village', uses: 1, order: 85 },
            FISTERIN_FRIDA: { name: 'Fisterin Frida', team: 'dorf', nightAction: true, actionType: 'find_wiebke', order: 60, special: 'dies_on_wolf_touch' },

            // Eigenes Ziel
            WUT_WIEBKE: { name: 'Wut Wiebke', team: 'eigen', nightAction: true, actionType: 'vote_with_wolves', order: 12, winCondition: 'last_alive' },
            SUIZID_SUSIE: { name: 'Suizid Susie', team: 'eigen', nightAction: false, winCondition: 'lynched_day_1' },
            DOPPELMORAL_DOERTHE: { name: 'Doppelmoral-D√∂rthe', team: 'dorf', nightAction: true, actionType: 'observe_wolves', order: 11, winCondition: 'dorf_wins' }, // Gewinnt mit Dorf, obwohl sie aufwacht
            KONVERSIONSTHERAPIE_KONNY: { name: 'Konversionstherapie Konny', team: 'dorf', nightAction: true, actionType: 'find_twink', order: 51 },
            GLORYHOLE_GUENNI: { name: 'Gloryhole G√ºnni', team: 'dorf', nightAction: false, dayAction: true, special: 'knows_twink_konny' }, // Nachtaktion nur f√ºr Schutz-Check
            BLUTMAGIERIN_BEATRIX: { name: 'Blutmagierin Beatrix', team: 'dorf', nightAction: false, dayAction: true, actionType: 'intervene_lynch', uses: 1 },

            // Sonderrollen
            KLATSCH_KAETHE: { name: 'Klatsch-K√§the', team: 'zusatz', nightAction: true, actionType: 'spread_rumor', uses: 3, order: 72 }, // Team h√§ngt vom Basis-Spieler ab
            VOLLSUFF_VALENTIN: { name: 'Vollsuff-Valentin', team: 'dorf', nightAction: true, actionType: 'link_three', frequency: 'firstNightOnly', uses: 1, order: 1 },
            WAHRSAGER_WEBERIN_WALTRAUD: { name: 'Wahrsager-Weberin Waltraud', team: 'dorf', nightAction: true, actionType: 'link_two', uses: 1, order: 2 },

            // Gef√§hrliche / Unberechenbare
            KETA_ZIEHERIN_CLAUDIA: { name: 'Keta-Zieherin Claudia', team: 'dorf', nightAction: true, actionType: 'observe_all_but_wolves', frequency: 'oddNightsOnly', order: 20, special: 'dies_on_reveal' }, // Nacht 1, 3, 5...
            ILTUSSY: { name: 'Iltussy', team: 'dorf', nightAction: true, actionType: 'infect_roll', frequency: 'evenNightsOnly', order: 25 }, // Nacht 2, 4, 6...
            TRIP_SITTERIN_TANJA: { name: 'Trip-Sitterin Tanja', team: 'dorf', nightAction: true, actionType: 'retten_oder_ausschalten', uses: { retten: 1, ausschalten: 1 }, order: 30 },
            GIFT_MISCHERIN_GERTRUD: { name: 'Giftmischerin Gertrud', team: 'dorf', nightAction: true, actionType: 'poison', uses: 1, order: 31 }, // Korrigierter Key
            TRAVESTIEKUENSTLER_TRISTAN: { name: 'Travestiek√ºnstler Tristan', team: 'dorf', nightAction: false, dayAction: true, actionType: 'switch_team', uses: 1, special: 'can_become_wolf' }, // Team kann wechseln

            // Besondere Dynamik
            DER_TWINK: { name: 'Der Twink', team: 'dorf', nightAction: true, actionType: 'visit_and_learn', order: 50, special: 'hunted_by_priest' },
            DER_GEILE_PRIESTER: { name: 'Der geile Priester', team: 'dorf', nightAction: true, actionType: 'hunt_twink', order: 55 },

            // Werwolf
            WERWOLF: { name: 'Werwolf', team: 'werwolf', nightAction: true, actionType: 'kill', order: 10 },
        };

        // --- DOM Elemente ---
        // (Bereits oben deklariert, hier nur zur √úbersicht)
        const allScreens = document.querySelectorAll('.screen');
        const playerCountButtonsContainer = document.getElementById('player-count-buttons');
        const playerNameInputsContainer = document.getElementById('player-name-inputs');
        const btnGoToRoleAssignment = document.getElementById('btn-go-to-role-assignment');
        const playerRoleAssignmentContainer = document.getElementById('player-role-assignment');
        const roleAssignmentError = document.getElementById('role-assignment-error');
        const btnStartGame = document.getElementById('btn-start-game');
        const nightCounter = document.getElementById('night-counter');
        const nightRoleAction = document.getElementById('night-role-action');
        const nightInstruction = document.getElementById('night-instruction');
        const nightPlayerList = document.getElementById('night-player-list');
        const nightSpecialUI = document.getElementById('night-special-ui');
        const selectionInfo = document.getElementById('selection-info');
        const btnNextAction = document.getElementById('btn-next-action');
        const dayCounter = document.getElementById('day-counter');
        const dayEventsList = document.getElementById('day-events-list');
        const dayEventAnnouncement = document.getElementById('day-event-announcement');
        const dayEventDetails = document.getElementById('day-event-details');
        const dayPlayerListStatus = document.getElementById('day-player-list-status');
        const btnStartDiscussion = document.getElementById('btn-start-discussion');
        const dayCounterVote = document.getElementById('day-counter-vote');
        const dayVoteList = document.getElementById('day-vote-list');
        const dayVoteTimer = document.getElementById('day-vote-timer');
        const dayVoteRestrictions = document.getElementById('day-vote-restrictions');
        const lynchSelectionInfo = document.getElementById('lynch-selection-info');
        const beatrixInterventionDiv = document.getElementById('beatrix-intervention');
        const btnBeatrixIntervene = document.getElementById('btn-beatrix-intervene');
        const beatrixResultSpan = document.getElementById('beatrix-result');
        const btnConfirmLynch = document.getElementById('btn-confirm-lynch');
        const lynchResultText = document.getElementById('lynch-result-text');
        const lynchRoleReveal = document.getElementById('lynch-role-reveal');
        const lynchConsequences = document.getElementById('lynch-consequences');
        const lynchPlayerListStatus = document.getElementById('lynch-player-list-status');
        const btnStartNextNight = document.getElementById('btn-start-next-night');
        const gameOverMessage = document.getElementById('game-over-message');
        const winnersList = document.getElementById('winners-list');
        const btnNewGame = document.getElementById('btn-new-game');
        const btnEventsYes = document.getElementById('btn-events-yes');
        const btnEventsNo = document.getElementById('btn-events-no');

        let discussionTimerInterval = null; // F√ºr den Timer

        // --- Hilfsfunktionen ---
        function showScreen(screenId) {
            allScreens.forEach(screen => {
                screen.classList.remove('active');
            });
            const screenToShow = document.getElementById(screenId);
            if (screenToShow) {
                screenToShow.classList.add('active');
                gameState.currentScreen = screenId;
                console.log("Showing screen:", screenId);
            } else {
                console.error("Screen not found:", screenId);
                // Fallback auf Startbildschirm
                showScreen('screen-setup-players');
            }
        }

        function getPlayerData(playerId) {
            return gameState.players.find(p => p.id === playerId);
        }
        function getPlayerByName(playerName) {
             return gameState.players.find(p => p.name === playerName);
        }

        function getLivingPlayers(team = null) {
            return gameState.players.filter(p => p.status === 'alive' && (team === null || p.roleDetails.team === team || (team === 'dorf' && p.roleDetails.winCondition === 'dorf_wins')));
        }

        function getDeadPlayers() {
            return gameState.players.filter(p => p.status === 'dead');
        }

        function getRoleDefinitionByKey(roleKey) {
            return ROLES[roleKey];
        }

        function getRoleDefinitionByName(roleName) {
            return Object.values(ROLES).find(r => r.name === roleName);
        }

        function logGameEvent(message) {
            console.log(message);
            gameState.gameLog.push({ time: new Date().toLocaleTimeString(), message: message });
        }

        function showTemporaryMessage(elementId, message, duration = 3000) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = message;
                element.classList.remove('hidden');
                setTimeout(() => {
                    element.textContent = '';
                    element.classList.add('hidden');
                }, duration);
            }
        }

        // --- Spiel-Setup ---
        function setupPlayerCountButtons() {
            playerCountButtonsContainer.innerHTML = ''; // Clear existing buttons
            for (let i = 8; i <= 15; i++) {
                const button = document.createElement('button');
                button.textContent = i;
                button.value = i;
                button.onclick = () => selectPlayerCount(i);
                playerCountButtonsContainer.appendChild(button);
            }
        }

        function selectPlayerCount(count) {
            gameState.playerCount = count;
            logGameEvent(`Spieleranzahl auf ${count} gesetzt.`);
            setupNameInputs();
            showScreen('screen-setup-names');
        }

        function setupNameInputs() {
            playerNameInputsContainer.innerHTML = '';
             // Reset players array when setting up names for a new game or count change
            gameState.players = [];
            for (let i = 0; i < gameState.playerCount; i++) {
                const div = document.createElement('div');
                div.classList.add('flex', 'items-center', 'space-x-2', 'mb-2');
                const label = document.createElement('label');
                label.textContent = `Spieler ${i + 1}:`;
                label.htmlFor = `player-name-${i}`;
                label.classList.add('w-20', 'flex-shrink-0');
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `player-name-${i}`;
                input.placeholder = `Name Spieler ${i + 1}`;
                input.value = `Spieler ${i + 1}`; // Default name
                input.classList.add('flex-grow');
                div.appendChild(label);
                div.appendChild(input);
                playerNameInputsContainer.appendChild(div);

                 // Add player object placeholder
                gameState.players.push({
                    id: `player-${i}`,
                    name: input.value, // Use default name initially
                    role: null,
                    roleKey: null,
                    roleDetails: null,
                    status: 'alive',
                    isProtected: false,
                    isPoisoned: false,
                    poisonTimer: 0,
                    linkedTo: [],
                    clientForDielenschleiferin: false,
                    misc: {}
                });
            }
        }


        function setupRoleAssignment() {
            playerRoleAssignmentContainer.innerHTML = '';
            roleAssignmentError.classList.add('hidden');
            roleAssignmentError.textContent = '';

            // Rollen f√ºr Dropdown vorbereiten
            const availableRoles = Object.keys(ROLES).map(key => ({ key: key, name: ROLES[key].name }));
            availableRoles.sort((a, b) => a.name.localeCompare(b.name)); // Alphabetisch sortieren

            // Update player names from input fields before creating role assignments
            for (let i = 0; i < gameState.playerCount; i++) {
                 const input = document.getElementById(`player-name-${i}`);
                 if (input && gameState.players[i]) {
                     gameState.players[i].name = input.value.trim() || `Spieler ${i + 1}`;
                 }
            }


            gameState.players.forEach((player, i) => {
                const div = document.createElement('div');
                div.classList.add('flex', 'items-center', 'space-x-2', 'mb-2');
                const nameLabel = document.createElement('span');
                nameLabel.textContent = `${player.name}:`;
                nameLabel.classList.add('w-32', 'flex-shrink-0', 'truncate'); // Mehr Platz f√ºr Namen

                const select = document.createElement('select');
                select.id = `player-role-${i}`;
                select.classList.add('flex-grow');
                select.dataset.playerId = player.id; // Store player id for later retrieval

                // Standard-Option
                const defaultOption = document.createElement('option');
                defaultOption.value = "";
                defaultOption.textContent = "Rolle ausw√§hlen...";
                select.appendChild(defaultOption);

                // Rollen hinzuf√ºgen
                availableRoles.forEach(role => {
                    const option = document.createElement('option');
                    option.value = role.key;
                    option.textContent = role.name;
                    // Pre-select if role was already assigned (e.g., going back and forth)
                    if (player.roleKey === role.key) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });

                div.appendChild(nameLabel);
                div.appendChild(select);
                playerRoleAssignmentContainer.appendChild(div);
            });
            showScreen('screen-setup-roles');
        }

        function validateAndStartGame() {
            const assignedRolesMap = new Map(); // key: roleKey, value: count
            let isValid = true;
            let errorMessage = "";
            roleAssignmentError.classList.add('hidden');
            let assignedRoleKeys = []; // Track assigned keys for incompatibility checks

            // 1. Rollen auslesen und Spielern zuweisen
            for (let i = 0; i < gameState.playerCount; i++) {
                const select = document.getElementById(`player-role-${i}`);
                const roleKey = select.value;
                const playerId = select.dataset.playerId; // Get player id from data attribute
                const player = getPlayerData(playerId);

                if (!player) {
                    console.error(`Player not found for index ${i} / id ${playerId}`);
                    isValid = false;
                    errorMessage = "Interner Fehler: Spielerdaten nicht gefunden.";
                    break;
                }

                if (!roleKey) {
                    isValid = false;
                    errorMessage = "Bitte allen Spielern eine Rolle zuweisen.";
                    break;
                }
                player.roleKey = roleKey;
                player.roleDetails = ROLES[roleKey];
                player.role = player.roleDetails.name;
                assignedRoleKeys.push(roleKey);

                // Z√§hle die zugewiesenen Rollen
                assignedRolesMap.set(roleKey, (assignedRolesMap.get(roleKey) || 0) + 1);


                // F√§higkeiten initialisieren
                 if (player.roleDetails.uses) {
                    gameState.usedAbilities[player.id] = {};
                    if (typeof player.roleDetails.uses === 'number' && player.roleDetails.uses !== -1) {
                         // F√ºr einfache einmalige Nutzung (uses: 1)
                         gameState.usedAbilities[player.id] = 0;
                    } else if (typeof player.roleDetails.uses === 'object') {
                         // F√ºr Rollen mit mehreren benannten F√§higkeiten (uses: { ability1: 1, ability2: 1 })
                         for (const key in player.roleDetails.uses) {
                             gameState.usedAbilities[player.id][key] = 0; // Z√§hler pro F√§higkeitstyp
                         }
                    }
                 } else if (player.roleDetails.uses === 1) { // Fallback f√ºr uses: 1
                     gameState.usedAbilities[player.id] = 0;
                 }


                 // Sonderinitialisierungen
                 if (player.roleKey === 'GLORYHOLE_GUENNI') {
                    // Suche nach Twink und Konny erst *nachdem* alle Rollen zugewiesen wurden
                 }
                 if (player.roleKey === 'DOPPELMORAL_DOERTHE') {
                     player.misc.knowsWerwolves = true; // Markierung, dass sie die WW kennt
                 }
                 // Reset misc data
                 player.misc = {};

            }

            if (!isValid) {
                roleAssignmentError.textContent = errorMessage;
                roleAssignmentError.classList.remove('hidden');
                return;
            }

             // Post-assignment initializations
             gameState.players.forEach(player => {
                 if (player.roleKey === 'GLORYHOLE_GUENNI') {
                     const twink = gameState.players.find(p => p.roleKey === 'DER_TWINK');
                     const konny = gameState.players.find(p => p.roleKey === 'KONVERSIONSTHERAPIE_KONNY');
                     player.misc.knowsTwinkId = twink ? twink.id : null;
                     player.misc.knowsKonnyId = konny ? konny.id : null;
                     logGameEvent(`Gloryhole G√ºnni Initialisierung: Kennt Twink (${!!player.misc.knowsTwinkId}), Kennt Konny (${!!player.misc.knowsKonnyId})`);
                 }
             });


            // 2. Werwolfanzahl pr√ºfen
            const expectedWWCount = gameState.config.werwolfCount[gameState.playerCount];
            const actualWWCount = assignedRolesMap.get('WERWOLF') || 0;
            if (actualWWCount !== expectedWWCount) {
                isValid = false;
                errorMessage = `Falsche Anzahl Werw√∂lfe! F√ºr ${gameState.playerCount} Spieler werden ${expectedWWCount} Werw√∂lfe ben√∂tigt, aber ${actualWWCount} wurden zugewiesen.`;
            }

            // 3. Inkompatible Rollen pr√ºfen
            const hasValentin = assignedRoleKeys.includes('VOLLSUFF_VALENTIN');
            const hasWaltraud = assignedRoleKeys.includes('WAHRSAGER_WEBERIN_WALTRAUD');
            if (hasValentin && hasWaltraud) {
                isValid = false;
                errorMessage = "Vollsuff-Valentin und Wahrsager-Weberin Waltraud d√ºrfen nicht im selben Spiel sein.";
            }
            const hasWiebke = assignedRoleKeys.includes('WUT_WIEBKE');
            const hasDoerthe = assignedRoleKeys.includes('DOPPELMORAL_DOERTHE');
            if (hasWiebke && hasDoerthe) {
                isValid = false;
                errorMessage = "Wut Wiebke und Doppelmoral-D√∂rthe d√ºrfen nicht im selben Spiel sein.";
            }
            // Pr√ºfung: Sind ben√∂tigte Rollen vorhanden? (z.B. B√§uerin braucht B√§rbel)
            if (assignedRoleKeys.includes('BOY_BUTTER_BAEUERIN') && !assignedRoleKeys.includes('BORDELL_BAERBEL')) {
                 isValid = false;
                 errorMessage = "Die Boy-Butter B√§uerin ben√∂tigt Bordell B√§rbel im Spiel.";
            }
            if (assignedRoleKeys.includes('KONVERSIONSTHERAPIE_KONNY') && !assignedRoleKeys.includes('DER_TWINK')) {
                 isValid = false;
                 errorMessage = "Konversionstherapie Konny ben√∂tigt den Twink im Spiel.";
            }
             if (assignedRoleKeys.includes('DER_GEILE_PRIESTER') && !assignedRoleKeys.includes('DER_TWINK')) {
                 isValid = false;
                 errorMessage = "Der geile Priester ben√∂tigt den Twink im Spiel.";
            }
             if (assignedRoleKeys.includes('GLORYHOLE_GUENNI') && (!assignedRoleKeys.includes('DER_TWINK') || !assignedRoleKeys.includes('KONVERSIONSTHERAPIE_KONNY'))) {
                 isValid = false;
                 errorMessage = "Gloryhole G√ºnni ben√∂tigt den Twink UND Konversionstherapie Konny im Spiel.";
            }
             if (assignedRoleKeys.includes('FISTERIN_FRIDA') && !assignedRoleKeys.includes('WUT_WIEBKE')) {
                 isValid = false;
                 errorMessage = "Fisterin Frida ben√∂tigt Wut Wiebke im Spiel.";
            }
             // Pr√ºfung: Giftmischerin und Tanja (optional, aber im Original erw√§hnt)
             const hasGertrud = assignedRoleKeys.includes('GIFT_MISCHERIN_GERTRUD');
             const hasTanja = assignedRoleKeys.includes('TRIP_SITTERIN_TANJA');
             // Keine direkte Inkompatibilit√§t, aber Hinweis vielleicht sinnvoll?


            if (!isValid) {
                roleAssignmentError.textContent = errorMessage;
                roleAssignmentError.classList.remove('hidden');
                return;
            }

            logGameEvent("Rollen zugewiesen und Spiel gestartet.");
            console.log("Final Player Setup:", gameState.players);
            showScreen('screen-setup-events'); // Gehe zur Event-Auswahl
        }

        function setupEvents(enabled) {
            gameState.specialConditions.eventsEnabled = enabled;
            logGameEvent(`Sonderereignisse ${enabled ? 'aktiviert' : 'deaktiviert'}.`);
            startNightPhase();
        }


        // --- Nachtphase Logik ---
        function startNightPhase() {
            gameState.night++;
            gameState.day = gameState.night; // Tag-Nummer entspricht der *kommenden* Tagesphase
            gameState.currentRoleIndex = -1;
            gameState.nightActions = [];
            gameState.lynchTarget = null;
            selectionInfo.textContent = '';
            nightSpecialUI.innerHTML = '';

            // Reset n√§chtliche Status / Infos
            gameState.players.forEach(p => {
                p.isProtected = false;
                p.clientForDielenschleiferin = false; // Wird jede Nacht neu gesetzt
                delete p.misc.sabineRolledSix;
                delete p.misc.priesterProtectedThisNight;
                delete p.misc.bauerProtectedThisNight;
                delete p.misc.baerbelSelfProtect;
                 delete p.misc.chaostrankActive; // Wird am Ende der Nacht aufgel√∂st
                 delete p.misc.blockWWActive; // Wird am Ende der Nacht aufgel√∂st
            });

            // Rollen f√ºr die Nachtphase filtern und sortieren
            gameState.rolesActingTonight = gameState.players
                .filter(p => p.status === 'alive' && p.roleDetails.nightAction)
                .filter(p => checkRoleCondition(p)) // Pr√ºfen, ob die Rolle aktiv ist (Frequenz, Nutzungslimit etc.)
                .sort((a, b) => (a.roleDetails.order || 999) - (b.roleDetails.order || 999)); // Sortieren nach Reihenfolge

            logGameEvent(`Nacht ${gameState.night} beginnt. Aktive Rollen: ${gameState.rolesActingTonight.map(p => p.role).join(', ')}`);
            nightCounter.textContent = gameState.night;
            showScreen('screen-night');
            nextNightAction();
        }

        function checkRoleCondition(player) {
            const role = player.roleDetails;
            const roleKey = player.roleKey;

            // Frequenz pr√ºfen
            if (role.frequency === 'firstNightOnly' && gameState.night !== 1) return false;
            if (role.frequency === 'oddNightsOnly' && gameState.night % 2 === 0) return false; // Ungerade N√§chte (1, 3, 5...)
            if (role.frequency === 'evenNightsOnly' && gameState.night % 2 !== 0) return false; // Gerade N√§chte (2, 4, 6...)

            // Nutzungslimit pr√ºfen
             if (role.uses) {
                 const usesLimit = role.uses;
                 const currentUses = gameState.usedAbilities[player.id];

                 if (typeof usesLimit === 'number' && usesLimit !== -1) {
                     // Einfache Z√§hlung (z.B. uses: 1)
                     if ((currentUses || 0) >= usesLimit) return false;
                 } else if (typeof usesLimit === 'object') {
                     // Z√§hlung pro F√§higkeit (z.B. uses: { retten: 1, ausschalten: 1 })
                     const currentAbilityUses = currentUses || {};
                     const canUseAny = Object.keys(usesLimit).some(key => (currentAbilityUses[key] || 0) < usesLimit[key]);
                     if (!canUseAny) return false;
                 }
                 // uses: -1 bedeutet unendlich, immer true
             }


            // Spezielle Bedingungen pr√ºfen
            if (role.condition === 'player_is_dead' && getDeadPlayers().length === 0) return false;
            if (role.condition === 'baerbel_not_found' && gameState.specialConditions.bauerFoundBaerbel) return false;
            if (roleKey === 'DER_TWINK' && gameState.specialConditions.twinkDeactivated) return false; // Konny hat ihn gefunden

            return true; // Rolle ist aktiv
        }


        function nextNightAction() {
            // Reset UI Elemente f√ºr die n√§chste Aktion
            nightSpecialUI.innerHTML = '';
            selectionInfo.textContent = '';
            btnNextAction.disabled = true; // Standardm√§√üig deaktiviert, bis Auswahl getroffen oder nicht n√∂tig
            btnNextAction.textContent = 'Aktion best√§tigen / N√§chster Schritt';
            btnNextAction.onclick = defaultNextActionButtonLogic; // Standard-Logik f√ºr den Button

            // Index erh√∂hen
            gameState.currentRoleIndex++;

            // Pr√ºfen, ob alle Rollen durch sind
            if (gameState.currentRoleIndex >= gameState.rolesActingTonight.length) {
                logGameEvent("Alle Nachtaktionen abgeschlossen.");
                resolveNightActions();
                return;
            }

            const currentPlayer = gameState.rolesActingTonight[gameState.currentRoleIndex];
            const role = currentPlayer.roleDetails;
            const roleKey = currentPlayer.roleKey;

            // √úberspringe passive oder redundante Aktionen
             if (role.actionType === 'observe_passive' || role.actionType === 'vote_with_wolves' || role.actionType === 'observe_wolves') {
                 logGameEvent(`√úberspringe passive Rolle: ${currentPlayer.name} (${currentPlayer.role})`);
                 setTimeout(nextNightAction, 50); // Kurze Verz√∂gerung, dann n√§chste Aktion
                 return;
             }
             // √úberspringe weitere Werw√∂lfe, wenn der erste schon gew√§hlt hat
             if (roleKey === 'WERWOLF' && gameState.nightActions.some(a => a.roleKey === 'WERWOLF' && a.action === 'kill')) {
                 logGameEvent(`√úberspringe weiteren Werwolf: ${currentPlayer.name}`);
                 setTimeout(nextNightAction, 50);
                 return;
             }

            // --- UI f√ºr die aktuelle Rolle vorbereiten ---
            logGameEvent(`Aktion f√ºr: ${currentPlayer.name} (${currentPlayer.role})`);
            nightRoleAction.textContent = `${currentPlayer.role} (${currentPlayer.name}), deine Aktion:`;

            let instruction = "";
            let targetType = 'player'; // player, multi-player, dead_player, special, none, player_optional
            let targetCount = 1;
            // Standard: Alle anderen Lebenden sind w√§hlbar
            let selectablePlayers = getLivingPlayers().filter(p => p.id !== currentPlayer.id);
            let requiresUIInteraction = true; // Bestimmt, ob der "Weiter"-Button sofort aktiv sein soll

            // --- Rollenspezifische UI und Logik ---
            switch (role.actionType) {
                 case 'kill': // Werwolf
                    nightRoleAction.textContent = `Werw√∂lfe, w√§hlt euer Opfer:`;
                    instruction = "Zeigt auf den Spieler, den ihr fressen wollt.";
                    selectablePlayers = getLivingPlayers().filter(p => p.roleDetails.team !== 'werwolf');
                    if (selectablePlayers.length === 0) { // Nur noch W√∂lfe √ºbrig?
                        instruction = "Es gibt niemanden mehr zu fressen.";
                        targetType = 'none';
                        requiresUIInteraction = false;
                    }
                    break;
                case 'choose_client': // Dielenschleiferin
                    instruction = "W√§hle einen Spieler, bei dem du morgen die Dielen schleifst.";
                    selectablePlayers = getLivingPlayers(); // Kann jeden w√§hlen
                    targetType = 'player_optional'; // Kann √ºberspringen
                    break;
                 case 'protect_neighbor': // Schutzschild-Sigrid
                    const neighbors = getNeighbors(currentPlayer.id);
                    instruction = `W√§hle einen deiner Nachbarn (${neighbors.map(n => n.name).join(' oder ')}) zum Besch√ºtzen.`;
                    selectablePlayers = neighbors;
                    targetType = 'player_optional';
                    if (neighbors.length === 0) {
                        instruction = "Du hast keine lebenden Nachbarn mehr zum Besch√ºtzen.";
                        targetType = 'none';
                        requiresUIInteraction = false;
                    }
                    break;
                case 'protect_guest': // Bordell B√§rbel
                    instruction = "Wen l√§dst du heute Nacht zu dir ein?";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'reveal_role': // Mansplaining Martin
                    instruction = "W√§hle einen Spieler, dessen Rolle du erfahren m√∂chtest.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'use_potion': // Kr√§uterhexe Hilde
                    instruction = "W√§hle einen Trank und ein Ziel.";
                    targetType = 'special';
                    setupHildeUI(currentPlayer);
                    requiresUIInteraction = false; // UI hat eigene Best√§tigung/Skip
                    break;
                case 'ask_dead': // Nekromant Norbert
                    instruction = "W√§hle einen toten Spieler als Medium und einen lebenden Spieler.";
                    targetType = 'special';
                    setupNorbertUI(currentPlayer);
                    requiresUIInteraction = false;
                    break;
                case 'find_baerbel': // Boy-Butter B√§uerin
                    instruction = "W√§hle einen Spieler und frage, ob es Bordell B√§rbel ist.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'sabine_actions': // √ñko Sabine
                    if (gameState.night === 1) {
                        instruction = "Der SL zeigt dir 3 m√∂gliche Werw√∂lfe (nur 1 ist korrekt).";
                        targetType = 'none';
                        const potentialTargets = getSabineTargets();
                        nightSpecialUI.innerHTML = `<p class="text-yellow-400">M√∂gliche Werw√∂lfe: ${potentialTargets.map(p=>p.name).join(', ')}</p>`;
                        requiresUIInteraction = false; // Nur Info
                    } else {
                        instruction = "W√ºrfle, um dich zu sch√ºtzen (ben√∂tigt eine 6).";
                        targetType = 'special';
                        setupSabineDiceUI(currentPlayer);
                        requiresUIInteraction = false; // UI hat eigene Logik
                    }
                    break;
                case 'revive': // Bestatterin Brunhilde
                     instruction = "W√§hle einen toten Spieler zur Wiederbelebung.";
                     selectablePlayers = getDeadPlayers();
                     targetType = 'dead_player_optional'; // Kann √ºberspringen
                     if (selectablePlayers.length === 0) {
                         instruction = "Es gibt niemanden zum Wiederbeleben.";
                         targetType = 'none';
                         requiresUIInteraction = false;
                     }
                     break;
                case 'check_wolf': // T√ºrsteher Toni
                    instruction = "W√§hle einen Spieler zum Abtasten.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'guard_village': // Wachmann Wenzel
                    instruction = "M√∂chtest du diese Nacht √ºber das Dorf wachen?";
                    targetType = 'special';
                    setupWenzelUI(currentPlayer);
                    requiresUIInteraction = false;
                    break;
                case 'find_wiebke': // Fisterin Frida
                    instruction = "W√§hle einen Spieler, um zu pr√ºfen, ob es Wut Wiebke ist. Vorsicht vor Werw√∂lfen!";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'find_twink': // Konversionstherapie Konny
                    instruction = "W√§hle einen Spieler, um zu pr√ºfen, ob es der Twink ist.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'spread_rumor': // Klatsch-K√§the
                    instruction = "W√§hle ein Ger√ºcht und einen Spieler.";
                    targetType = 'special';
                    setupKaetheUI(currentPlayer);
                    requiresUIInteraction = false;
                    break;
                case 'link_three': // Vollsuff-Valentin
                    instruction = "W√§hle DREI Spieler, die das Tr√§rchen bilden sollen.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'multi-player';
                    targetCount = 3;
                    if (selectablePlayers.length < 3) {
                         instruction = "Nicht gen√ºgend Spieler zum Verkuppeln vorhanden.";
                         targetType = 'none';
                         requiresUIInteraction = false;
                    }
                    break;
                case 'link_two': // Wahrsager-Weberin Waltraud
                    instruction = "W√§hle ZWEI Spieler, die verwoben werden sollen.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'multi-player';
                    targetCount = 2;
                     if (selectablePlayers.length < 2) {
                         instruction = "Nicht gen√ºgend Spieler zum Verweben vorhanden.";
                         targetType = 'none';
                         requiresUIInteraction = false;
                    }
                    break;
                case 'observe_all_but_wolves': // Keta-Zieherin Claudia
                    instruction = "Du beobachtest die Vorg√§nge der Nacht (au√üer die Werwolf-Aktion). Der SL informiert dich.";
                    targetType = 'none';
                    nightSpecialUI.innerHTML = `<p class="text-gray-400">(Spielleiter gibt Informationen an Claudia)</p>`;
                    requiresUIInteraction = false;
                    break;
                case 'infect_roll': // Iltussy
                    instruction = "W√§hle einen Dorfbewohner, zu dem du einen Iltis schickst, und w√ºrfle.";
                    selectablePlayers = getLivingPlayers().filter(p => p.id !== currentPlayer.id && p.roleDetails.team === 'dorf');
                    targetType = 'special';
                     if (selectablePlayers.length === 0) {
                         instruction = "Keine g√ºltigen Ziele f√ºr den Iltis.";
                         targetType = 'none';
                         requiresUIInteraction = false;
                     } else {
                         setupIltussyUI(currentPlayer, selectablePlayers);
                         requiresUIInteraction = false;
                     }
                    break;
                case 'retten_oder_ausschalten': // Trip-Sitterin Tanja
                    instruction = "M√∂chtest du retten oder ausschalten?";
                    targetType = 'special';
                    setupTanjaUI(currentPlayer);
                    requiresUIInteraction = false;
                    break;
                case 'poison': // Giftmischerin Gertrud
                    instruction = "W√§hle einen Spieler zum Vergiften.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'visit_and_learn': // Der Twink
                    instruction = "W√§hle einen Spieler, den du besuchen m√∂chtest.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                case 'hunt_twink': // Der geile Priester
                    instruction = "W√§hle einen Spieler, um zu pr√ºfen, ob es der Twink ist.";
                    selectablePlayers = getLivingPlayers();
                    targetType = 'player_optional';
                    break;
                default:
                    instruction = "Diese Rolle hat keine definierte Aktion f√ºr die App.";
                    targetType = 'none';
                    requiresUIInteraction = false;
                    logGameEvent(`Keine UI implementiert f√ºr ${role.actionType} von ${currentPlayer.role}`);
            }

            nightInstruction.textContent = instruction;

            // Rendere Spielerliste oder leere sie, wenn nicht ben√∂tigt
            if (targetType.startsWith('player') || targetType.startsWith('multi-player') || targetType.startsWith('dead_player')) {
                 renderNightPlayerList(currentPlayer, selectablePlayers, targetType, role.actionType, targetCount);
            } else {
                 renderNightPlayerList(currentPlayer, [], 'none'); // Leere Liste f√ºr 'special' oder 'none'
            }

            // Aktiviere/Deaktiviere "Weiter"-Button basierend darauf, ob eine UI-Interaktion n√∂tig ist
            btnNextAction.disabled = requiresUIInteraction;
            if (!requiresUIInteraction) {
                 btnNextAction.textContent = 'Weiter';
                 // Kurze Pause, damit der SL den Text lesen kann, bevor automatisch weitergegangen wird
                 setTimeout(() => {
                     // Nur weitermachen, wenn wir noch bei diesem Spieler sind und der Screen aktiv ist
                     if (gameState.currentScreen === 'screen-night' && gameState.rolesActingTonight[gameState.currentRoleIndex]?.id === currentPlayer.id) {
                          confirmNightAction(null); // Keine explizite Aktion vom Spieler n√∂tig
                     }
                 }, 1500); // 1.5 Sekunden Verz√∂gerung
            }
        }

        function defaultNextActionButtonLogic() {
             // Standard-Aktion f√ºr den "Weiter"-Button, wenn keine spezifische Logik zugewiesen wurde
             const currentPlayer = gameState.rolesActingTonight[gameState.currentRoleIndex];
             logGameEvent(`Weiter geklickt f√ºr ${currentPlayer?.name || 'unbekannt'}. Keine Aktion ausgew√§hlt oder n√∂tig.`);
             confirmNightAction(null); // Best√§tigt, dass keine Aktion gew√§hlt wurde oder die Aktion abgeschlossen ist
        }

        function confirmNightAction(actionData) {
            const currentPlayer = gameState.rolesActingTonight[gameState.currentRoleIndex];
            // Verhindere Best√§tigung, wenn Index nicht mehr stimmt (z.B. durch Timeout)
            if (!currentPlayer || gameState.currentRoleIndex >= gameState.rolesActingTonight.length) {
                 console.warn("confirmNightAction called but currentRoleIndex is out of bounds or currentPlayer is null.");
                 return;
            }

            if (actionData) {
                 let action = {
                    actor: currentPlayer.id,
                    role: currentPlayer.role,
                    roleKey: currentPlayer.roleKey, // F√ºge roleKey hinzu
                    action: currentPlayer.roleDetails.actionType,
                    ...actionData // F√ºgt target, targets, subAction etc. hinzu
                 };
                 gameState.nightActions.push(action);
                 logGameEvent(`Aktion gespeichert: ${JSON.stringify(action)}`);

                 // F√§higkeitennutzung z√§hlen
                 const abilityKeyBase = `${currentPlayer.id}_${action.action}`;
                 const abilityKeySub = action.subAction ? `${abilityKeyBase}_${action.subAction}` : abilityKeyBase;

                 if (gameState.usedAbilities[currentPlayer.id] !== undefined) {
                     if (typeof currentPlayer.roleDetails.uses === 'number' && currentPlayer.roleDetails.uses !== -1) {
                         // Einfacher Z√§hler f√ºr die Rolle
                         gameState.usedAbilities[currentPlayer.id]++;
                         console.log(`Used ability count for ${currentPlayer.name}: ${gameState.usedAbilities[currentPlayer.id]}`);
                     } else if (typeof currentPlayer.roleDetails.uses === 'object' && action.subAction) {
                         // Z√§hler pro F√§higkeitstyp
                         gameState.usedAbilities[currentPlayer.id][action.subAction] = (gameState.usedAbilities[currentPlayer.id][action.subAction] || 0) + 1;
                         console.log(`Used ability count for ${currentPlayer.name} (${action.subAction}): ${gameState.usedAbilities[currentPlayer.id][action.subAction]}`);
                     } else if (currentPlayer.roleDetails.uses === 1) {
                         // Fallback f√ºr Rollen, die nur uses: 1 haben
                          gameState.usedAbilities[currentPlayer.id] = (gameState.usedAbilities[currentPlayer.id] || 0) + 1;
                          console.log(`Used ability count for ${currentPlayer.name}: ${gameState.usedAbilities[currentPlayer.id]}`);
                     }
                 }

            } else {
                logGameEvent(`${currentPlayer.name} (${currentPlayer.role}) macht keine Aktion oder Aktion wurde √ºbersprungen.`);
            }
            // Zum n√§chsten Spieler/Aktion in der Nacht
            nextNightAction();
        }


        // --- UI Setup Funktionen f√ºr spezielle Rollen ---

        function setupHildeUI(player) {
            nightSpecialUI.innerHTML = '';
            const uses = player.roleDetails.uses;
            const used = gameState.usedAbilities[player.id] || {};
            const remaining = {
                protect: uses.protect - (used.protect || 0),
                block_ww: uses.block_ww - (used.block_ww || 0),
                chaos: uses.chaos - (used.chaos || 0)
            };

            const canUseAny = Object.values(remaining).some(count => count > 0);

            if (!canUseAny) {
                nightInstruction.textContent = "Du hast keine Tr√§nke mehr.";
                renderNightPlayerList(player, [], 'none');
                btnNextAction.textContent = 'Weiter';
                btnNextAction.disabled = false;
                btnNextAction.onclick = defaultNextActionButtonLogic; // Standard-Weiter-Logik
                return;
            }

            const selectLabel = document.createElement('label');
            selectLabel.textContent = "W√§hle einen Trank: ";
            selectLabel.htmlFor = 'hilde-potion-select';
            nightSpecialUI.appendChild(selectLabel);

            const selectPotion = document.createElement('select');
            selectPotion.id = 'hilde-potion-select';
            selectPotion.innerHTML = `<option value="">-- Bitte w√§hlen --</option>`;
            if (remaining.protect > 0) selectPotion.innerHTML += `<option value="protect">Schutztrank (${remaining.protect} √ºbrig)</option>`;
            if (remaining.block_ww > 0) selectPotion.innerHTML += `<option value="block_ww">Heil-/Blockadetrank (${remaining.block_ww} √ºbrig)</option>`;
            if (remaining.chaos > 0) selectPotion.innerHTML += `<option value="chaos">Chaostrank (${remaining.chaos} √ºbrig)</option>`;
            nightSpecialUI.appendChild(selectPotion);

            selectPotion.onchange = () => {
                const selectedPotion = selectPotion.value;
                if (selectedPotion) {
                    nightInstruction.textContent = `W√§hle einen Spieler f√ºr den ${ROLES.KRAEUTERHEXE_HILDE.name} (${selectedPotion}).`;
                    renderNightPlayerList(player, getLivingPlayers(), 'player', selectedPotion); // Zielauswahl erm√∂glichen
                    selectionInfo.textContent = 'W√§hle ein Ziel.';
                    btnNextAction.disabled = true; // Muss Ziel w√§hlen
                } else {
                    renderNightPlayerList(player, [], 'none'); // Keine Auswahl m√∂glich
                    selectionInfo.textContent = '';
                    btnNextAction.disabled = true;
                }
            };

             const skipButton = document.createElement('button');
             skipButton.textContent = "Keinen Trank verwenden";
             skipButton.classList.add('secondary', 'ml-4');
             skipButton.onclick = () => confirmNightAction(null);
             nightSpecialUI.appendChild(skipButton);

             renderNightPlayerList(player, [], 'none'); // Liste initial leer/inaktiv
             btnNextAction.disabled = true; // Muss erst Trank w√§hlen oder √ºberspringen
        }

        function setupNorbertUI(player) {
            nightSpecialUI.innerHTML = '';
            const deadPlayers = getDeadPlayers();
            const livingPlayers = getLivingPlayers();

            if (deadPlayers.length === 0 || livingPlayers.length === 0) {
                 nightInstruction.textContent = "Es gibt nicht gen√ºgend Spieler f√ºr deine F√§higkeit.";
                 renderNightPlayerList(player, [], 'none');
                 btnNextAction.textContent = 'Weiter';
                 btnNextAction.disabled = false;
                 btnNextAction.onclick = defaultNextActionButtonLogic;
                 return;
            }

            nightSpecialUI.innerHTML = `
                <div class="flex flex-wrap gap-4 items-center">
                    <div>
                        <label for="norbert-dead-select" class="block mb-1 text-sm font-medium">W√§hle den Geist:</label>
                        <select id="norbert-dead-select">
                            <option value="">-- Toter Spieler --</option>
                            ${deadPlayers.map(p => `<option value="${p.id}">${p.name} (${p.role})</option>`).join('')}
                        </select>
                    </div>
                    <div>
                        <label for="norbert-living-select" class="block mb-1 text-sm font-medium">√úber wen fragst du?</label>
                        <select id="norbert-living-select">
                            <option value="">-- Lebender Spieler --</option>
                            ${livingPlayers.map(p => `<option value="${p.id}">${p.name}</option>`).join('')}
                        </select>
                    </div>
                    <button id="norbert-confirm" class="self-end" disabled>Best√§tigen & SL Info geben</button>
                     <button id="norbert-skip" class="secondary self-end">√úberspringen</button>
                </div>
            `;

            const deadSelect = document.getElementById('norbert-dead-select');
            const livingSelect = document.getElementById('norbert-living-select');
            const confirmBtn = document.getElementById('norbert-confirm');
            const skipBtn = document.getElementById('norbert-skip');


            function checkSelection() {
                confirmBtn.disabled = !(deadSelect.value && livingSelect.value);
            }

            deadSelect.onchange = checkSelection;
            livingSelect.onchange = checkSelection;

            confirmBtn.onclick = () => {
                const deadPlayerId = deadSelect.value;
                const livingPlayerId = livingSelect.value;
                const livingPlayer = getPlayerData(livingPlayerId);
                const deadPlayer = getPlayerData(deadPlayerId);
                // SL gibt nonverbal Info
                logGameEvent(`${player.name} befragt Geist ${deadPlayer.name} √ºber ${livingPlayer.name}.`);
                selectionInfo.textContent = `SL: Gib ${player.name} Info √ºber ${livingPlayer.name} (Daumen hoch/runter).`;
                 // F√§higkeit als genutzt markieren (wird im confirmNightAction gemacht)
                confirmNightAction({ action: 'ask_dead', target: livingPlayer.name, medium: deadPlayer.name }); // Namen √ºbergeben f√ºr Logik
            };

             skipBtn.onclick = () => confirmNightAction(null);


            renderNightPlayerList(player, [], 'none'); // Keine Spielerliste n√∂tig
            btnNextAction.disabled = true; // Muss UI benutzen oder √ºberspringen
        }

        function setupSabineDiceUI(player) {
             nightSpecialUI.innerHTML = `
                <button id="sabine-roll-dice">W√ºrfeln f√ºr Schutz</button>
                <span id="sabine-dice-result" class="ml-4 text-xl font-bold"></span>
             `;
             const rollButton = document.getElementById('sabine-roll-dice');
             const resultSpan = document.getElementById('sabine-dice-result');

             rollButton.onclick = () => {
                 const roll = Math.floor(Math.random() * 6) + 1;
                 resultSpan.textContent = `W√ºrfel: ${roll}.`;
                 rollButton.disabled = true;
                 let protected = false;
                 if (roll === 6) {
                     player.misc.sabineRolledSix = true; // Im Spielerobjekt speichern
                     protected = true;
                     resultSpan.textContent += ' Gesch√ºtzt!';
                     resultSpan.classList.add('text-green-400');
                 } else {
                     resultSpan.textContent += ' Nicht gesch√ºtzt.';
                     resultSpan.classList.add('text-red-400');
                 }
                 logGameEvent(`${player.name} w√ºrfelt f√ºr Schutz: ${roll} (${protected ? 'gesch√ºtzt' : 'nicht gesch√ºtzt'}).`);
                 // Automatisch weiter nach kurzer Anzeige
                 setTimeout(() => {
                     // Nur weitermachen, wenn wir noch bei Sabine sind
                     if (gameState.currentScreen === 'screen-night' && gameState.rolesActingTonight[gameState.currentRoleIndex]?.id === player.id) {
                         confirmNightAction({ action: 'sabine_actions', rolled: roll, protected: protected });
                     }
                 }, 2500); // 2.5 Sekunden warten
             };
             renderNightPlayerList(player, [], 'none');
             btnNextAction.disabled = true; // Aktion l√§uft √ºber W√ºrfel-Button
        }

         function setupWenzelUI(player) {
             nightSpecialUI.innerHTML = `
                <button id="wenzel-yes">Ja, ich wache!</button>
                <button id="wenzel-no" class="secondary">Nein, ich schlafe lieber.</button>
             `;
             document.getElementById('wenzel-yes').onclick = () => {
                 logGameEvent(`${player.name} entscheidet sich zu wachen.`);
                 selectionInfo.textContent = "Das Dorf wird diese Nacht bewacht.";
                 confirmNightAction({ action: 'guard_village', watches: true });
             };
             document.getElementById('wenzel-no').onclick = () => {
                 logGameEvent(`${player.name} entscheidet sich zu schlafen.`);
                 selectionInfo.textContent = "Wenzel schl√§ft.";
                 confirmNightAction({ action: 'guard_village', watches: false });
             };
             renderNightPlayerList(player, [], 'none');
             btnNextAction.disabled = true; // Muss eine der Optionen w√§hlen
         }

         function setupKaetheUI(player) {
             nightSpecialUI.innerHTML = '';
             const rumors = [
                 "Man munkelt, dass du der Dorfgemeinschaft nicht wohlgesonnen bist.",
                 "Es gibt ein geheimes B√ºndnis im Dorf, und du scheinst darin verwickelt zu sein.",
                 "Man sagt, du hast eine d√ºstere Vorahnung √ºber das n√§chste Opfer ausgesprochen."
             ];
             const uses = player.roleDetails.uses;
             const usedCount = gameState.usedAbilities[player.id] || 0;
             const remaining = uses - usedCount;

             if (remaining <= 0) {
                 nightInstruction.textContent = "Du hast keine Ger√ºchte mehr zu verbreiten.";
                 renderNightPlayerList(player, [], 'none');
                 btnNextAction.textContent = 'Weiter';
                 btnNextAction.disabled = false;
                 btnNextAction.onclick = defaultNextActionButtonLogic;
                 return;
             }

             nightSpecialUI.innerHTML = `
                 <div class="space-y-2">
                    <div>
                        <label for="kaethe-rumor-select" class="block mb-1 text-sm font-medium">W√§hle ein Ger√ºcht (${remaining} √ºbrig):</label>
                        <select id="kaethe-rumor-select">
                            <option value="">-- Ger√ºcht w√§hlen --</option>
                            ${rumors.map((r, index) => `<option value="${index}">${r}</option>`).join('')}
                        </select>
                    </div>
                    <div>
                        <label for="kaethe-target-select" class="block mb-1 text-sm font-medium">√úber wen?</label>
                        <select id="kaethe-target-select" disabled>
                            <option value="">-- Spieler w√§hlen --</option>
                            ${getLivingPlayers().map(p => `<option value="${p.id}">${p.name}</option>`).join('')}
                        </select>
                    </div>
                    <button id="kaethe-confirm" class="mt-2" disabled>Ger√ºcht streuen</button>
                    <button id="kaethe-skip" class="secondary">√úberspringen</button>
                 </div>
             `;

             const rumorSelect = document.getElementById('kaethe-rumor-select');
             const targetSelect = document.getElementById('kaethe-target-select');
             const confirmBtn = document.getElementById('kaethe-confirm');
             const skipBtn = document.getElementById('kaethe-skip');

             function checkKaetheSelection() {
                 const rumorSelected = rumorSelect.value !== "";
                 const targetSelected = targetSelect.value !== "";
                 targetSelect.disabled = !rumorSelected;
                 confirmBtn.disabled = !(rumorSelected && targetSelected);
             }

             rumorSelect.onchange = checkKaetheSelection;
             targetSelect.onchange = checkKaetheSelection;

             confirmBtn.onclick = () => {
                 const targetPlayerId = targetSelect.value;
                 const rumorIndex = parseInt(rumorSelect.value);
                 const rumorText = rumors[rumorIndex];
                 logGameEvent(`${player.name} verbreitet Ger√ºcht '${rumorIndex + 1}' √ºber ${getPlayerData(targetPlayerId).name}.`);
                 selectionInfo.textContent = `Ger√ºcht √ºber ${getPlayerData(targetPlayerId).name} wird am Tag verk√ºndet.`;
                 confirmNightAction({ action: 'spread_rumor', target: getPlayerData(targetPlayerId).name, rumorIndex: rumorIndex, rumorText: rumorText });
             };

             skipBtn.onclick = () => confirmNightAction(null);

             renderNightPlayerList(player, [], 'none');
             btnNextAction.disabled = true; // Muss UI benutzen oder √ºberspringen
         }

         function setupIltussyUI(player, selectableTargets) {
             nightSpecialUI.innerHTML = `
                 <div>
                     <label for="iltussy-target-select" class="block mb-1 text-sm font-medium">W√§hle ein Ziel f√ºr den Iltis:</label>
                     <select id="iltussy-target-select">
                         <option value="">-- Spieler w√§hlen --</option>
                         ${selectableTargets.map(p => `<option value="${p.id}">${p.name}</option>`).join('')}
                     </select>
                 </div>
                 <div class="mt-2">
                     <button id="iltussy-roll-dice" disabled>W√ºrfeln</button>
                     <span id="iltussy-dice-result" class="ml-4 text-xl font-bold"></span>
                 </div>
                 <button id="iltussy-skip" class="secondary mt-2">√úberspringen</button>
             `;

             const targetSelect = document.getElementById('iltussy-target-select');
             const rollButton = document.getElementById('iltussy-roll-dice');
             const resultSpan = document.getElementById('iltussy-dice-result');
             const skipBtn = document.getElementById('iltussy-skip');

             targetSelect.onchange = () => {
                 rollButton.disabled = targetSelect.value === "";
             };

             rollButton.onclick = () => {
                 const targetPlayerId = targetSelect.value;
                 const targetPlayer = getPlayerData(targetPlayerId);
                 if (!targetPlayer) return;

                 const roll = Math.floor(Math.random() * 6) + 1;
                 resultSpan.textContent = `W√ºrfel: ${roll}.`;
                 rollButton.disabled = true;
                 targetSelect.disabled = true;
                 skipBtn.disabled = true;

                 let infection = false;
                 if (roll === 6) {
                     infection = true;
                     resultSpan.textContent += ` ${targetPlayer.name} wird infiziert!`;
                     resultSpan.classList.add('text-green-400');
                 } else {
                     resultSpan.textContent += ' Nichts passiert.';
                     resultSpan.classList.remove('text-green-400');
                 }
                 logGameEvent(`${player.name} schickt Iltis zu ${targetPlayer.name}, w√ºrfelt ${roll}. ${infection ? 'Infiziert!' : 'Keine Infektion.'}`);

                 setTimeout(() => {
                     if (gameState.currentScreen === 'screen-night' && gameState.rolesActingTonight[gameState.currentRoleIndex]?.id === player.id) {
                         confirmNightAction({ action: 'infect_roll', target: targetPlayer.name, rolled: roll, infected: infection });
                     }
                 }, 2500);
             };

             skipBtn.onclick = () => confirmNightAction(null);

             renderNightPlayerList(player, [], 'none');
             btnNextAction.disabled = true; // Muss UI benutzen oder √ºberspringen
         }

         function setupTanjaUI(player) {
            nightSpecialUI.innerHTML = '';
            const uses = player.roleDetails.uses;
            const used = gameState.usedAbilities[player.id] || {};
            const canRetten = (used.retten || 0) < uses.retten;
            const canAusschalten = (used.ausschalten || 0) < uses.ausschalten;
            // Finde das potenzielle WW-Opfer aus den bisherigen Aktionen DIESER Nacht
            const wwAction = gameState.nightActions.find(a => a.action === 'kill' && a.roleKey === 'WERWOLF');
            const wwOpferId = wwAction ? getPlayerByName(wwAction.target)?.id : null;
            const wwOpfer = getPlayerData(wwOpferId);
            const wwOpferName = wwOpfer?.name;

            if (!canRetten && !canAusschalten) {
                nightInstruction.textContent = "Du hast keine Aktionen mehr verf√ºgbar.";
                renderNightPlayerList(player, [], 'none');
                btnNextAction.textContent = 'Weiter';
                btnNextAction.disabled = false;
                btnNextAction.onclick = defaultNextActionButtonLogic;
                return;
            }

            let buttonsHTML = '';
            if (canRetten && wwOpfer && wwOpfer.status === 'alive') { // Nur retten, wenn es ein lebendes Opfer gibt
                buttonsHTML += `<button id="tanja-retten" data-target="${wwOpferName}">Opfer (${wwOpferName}) retten (${uses.retten - (used.retten || 0)} √ºbrig)</button>`;
            } else if (canRetten) {
                 buttonsHTML += `<button disabled class="secondary">Retten nicht m√∂glich (Kein WW-Opfer diese Nacht)</button>`;
            }

            if (canAusschalten) {
                buttonsHTML += `<button id="tanja-ausschalten">Jemanden ausschalten (${uses.ausschalten - (used.ausschalten || 0)} √ºbrig)</button>`;
            }

            buttonsHTML += `<button id="tanja-skip" class="secondary">√úberspringen</button>`;
            nightSpecialUI.innerHTML = `<div class="flex flex-wrap gap-2">${buttonsHTML}</div>`;

            const btnRetten = document.getElementById('tanja-retten');
            const btnAusschalten = document.getElementById('tanja-ausschalten');
            const btnSkip = document.getElementById('tanja-skip');

            if (btnRetten) {
                btnRetten.onclick = () => {
                    const targetName = btnRetten.dataset.target;
                    logGameEvent(`${player.name} rettet ${targetName}.`);
                    selectionInfo.textContent = `${targetName} wurde gerettet.`;
                    // Markiere die F√§higkeit als genutzt f√ºr diese Aktion
                    // gameState.usedAbilities[player.id]['retten'] = (gameState.usedAbilities[player.id]['retten'] || 0) + 1; // Wird in confirmNightAction gemacht
                    confirmNightAction({ action: 'retten_oder_ausschalten', subAction: 'retten', target: targetName });
                };
            }

            if (btnAusschalten) {
                btnAusschalten.onclick = () => {
                    nightInstruction.textContent = "W√§hle einen Spieler zum Ausschalten.";
                    nightSpecialUI.innerHTML = ''; // Clear buttons
                    renderNightPlayerList(player, getLivingPlayers().filter(p => p.id !== player.id), 'player', 'ausschalten');
                    selectionInfo.textContent = 'W√§hle ein Ziel.';
                    btnNextAction.disabled = true; // Muss Ziel w√§hlen
                };
            }

            btnSkip.onclick = () => confirmNightAction(null);

            renderNightPlayerList(player, [], 'none'); // Liste initial leer/inaktiv
            btnNextAction.disabled = true; // Muss Aktion w√§hlen oder √ºberspringen
         }

        // --- Gemeinsame Render-Funktion f√ºr Spielerlisten ---
        function renderNightPlayerList(currentPlayer, selectablePlayers, targetType, actionContext = null, targetCount = 1) {
            listElement = nightPlayerList; // Sicherstellen, dass wir die Nachtliste verwenden
             listElement.innerHTML = '';
             let currentSelection = []; // F√ºr Mehrfachauswahl

             // F√ºge "Nichts tun / √úberspringen"-Button hinzu, wenn optional
             const isOptional = targetType.endsWith('_optional');
             if (isOptional && targetType !== 'special') { // Special UIs haben eigenen Skip
                 const liSkip = document.createElement('li');
                 liSkip.style.backgroundColor = 'transparent';
                 const skipButton = document.createElement('button');
                 skipButton.textContent = 'Keine Aktion / √úberspringen';
                 skipButton.classList.add('secondary', 'w-full', 'mt-2');
                 skipButton.onclick = () => confirmNightAction(null);
                 liSkip.appendChild(skipButton);
                 listElement.appendChild(liSkip);
                 targetType = targetType.replace('_optional', ''); // Normalen Typ f√ºr weitere Logik verwenden
             }

             const displayPlayers = (targetType === 'dead_player') ? getDeadPlayers() : getLivingPlayers();

             displayPlayers.forEach(p => {
                 const li = document.createElement('li');
                 li.dataset.playerId = p.id;

                 const infoDiv = document.createElement('div');
                 infoDiv.classList.add('player-info');
                 const nameSpan = document.createElement('span');
                 nameSpan.textContent = p.name;
                 nameSpan.classList.add(p.status === 'alive' ? 'status-alive' : 'status-dead');
                 infoDiv.appendChild(nameSpan);

                 // Nur tote Rollen anzeigen
                 if (p.status === 'dead') {
                    const roleSpan = document.createElement('span');
                    roleSpan.textContent = ` (${p.role})`;
                    roleSpan.classList.add('role-info');
                    infoDiv.appendChild(roleSpan);
                 }

                 // Icons etc. (wie in der anderen renderPlayerList)
                 const iconsDiv = document.createElement('div');
                 iconsDiv.classList.add('flex', 'items-center', 'space-x-1', 'mt-1', 'md:mt-0');
                 // ... (Icons hinzuf√ºgen wie in renderPlayerList) ...
                 infoDiv.appendChild(iconsDiv);
                 li.appendChild(infoDiv);


                 // Interaktive Elemente
                 const isSelectable = selectablePlayers.some(sp => sp.id === p.id);
                 if (isSelectable && targetType !== 'none') {
                     const actionsDiv = document.createElement('div');
                     actionsDiv.classList.add('player-actions');
                     const selectButton = document.createElement('button');
                     selectButton.textContent = 'W√§hlen';
                     selectButton.onclick = (event) => {
                         event.stopPropagation();
                         const targetName = p.name; // Namen f√ºr die Aktion verwenden
                         const targetId = p.id;

                         if (targetType === 'player' || targetType === 'dead_player') {
                             document.querySelectorAll(`#${listElement.id} li`).forEach(item => item.classList.remove('selected'));
                             li.classList.add('selected');
                             selectionInfo.textContent = `Ausgew√§hlt: ${targetName}`;
                             confirmNightAction({ target: targetName, subAction: actionContext });
                         } else if (targetType === 'multi-player') {
                             li.classList.toggle('selected');
                             if (li.classList.contains('selected')) {
                                 if (!currentSelection.includes(targetName)) currentSelection.push(targetName);
                             } else {
                                 currentSelection = currentSelection.filter(name => name !== targetName);
                             }
                             selectionInfo.textContent = `Ausgew√§hlt (${currentSelection.length}/${targetCount}): ${currentSelection.join(', ')}`;
                             btnNextAction.disabled = currentSelection.length !== targetCount;
                             if (!btnNextAction.disabled) {
                                 btnNextAction.onclick = () => confirmNightAction({ targets: currentSelection, subAction: actionContext });
                             } else {
                                 btnNextAction.onclick = defaultNextActionButtonLogic; // Reset auf Standard, falls Auswahl ung√ºltig wird
                             }
                         }
                     };
                     actionsDiv.appendChild(selectButton);
                     li.appendChild(actionsDiv);
                 } else {
                      // Nicht w√§hlbare Spieler ausgrauen
                      if (p.status === 'alive') li.style.opacity = "0.5";
                 }

                 listElement.appendChild(li);
             });
        }

        // --- Nacht Aktionsauswertung (resolveNightActions) ---
        // Beh√§lt die vorhandene Logik bei, stellt aber sicher, dass alle neuen actionTypes
        // und subActions korrekt in nightSummary gesammelt werden.
        function resolveNightActions() {
            logGameEvent("Beginne Aufl√∂sung der Nachtaktionen.");
            dayEventsList.innerHTML = '';
            let deathsThisNight = []; // Spieler-Objekte
            let messages = []; // String-Nachrichten f√ºr die Anzeige
            let nightSummary = {
                wwTarget: null, // ID des WW-Ziels
                protections: {}, // targetId: protectorRoleKey
                heals: [], // targetId (Tanja Rettung)
                poisons: [], // { targetId: targetId, actorId: actorId } (Gertrud)
                blocks: [], // targetId (Hilde Blockade)
                chaosTargets: [], // targetId (Hilde Chaos)
                revives: [], // targetId (Brunhilde)
                infections: [], // { targetId: targetId, actorId: actorId } (Iltussy)
                linked: [], // Array von IDs [id1, id2] oder [id1, id2, id3]
                linkedType: null, // 'valentin' oder 'waltraud'
                dielenClient: null, // targetId
                ausschaltenTarget: null, // { targetId: targetId, actorId: actorId } (Tanja)
                wenzelWatched: false,
                rumors: [], // {targetId, rumorText}
                fridaTarget: null, // {targetId: targetId, actorId: actorId}
                fridaDied: false,
                twinkVisitTarget: null, // {targetId: targetId, actorId: actorId}
                twinkKilledByPriest: false,
                konnyTarget: null, // {targetId: targetId, actorId: actorId}
                twinkAbilityDeactivated: gameState.specialConditions.twinkDeactivated, // √úbernehme bestehenden Status
                priestTarget: null, // {targetId: targetId, actorId: actorId}
                bauerTarget: null, // {targetId: targetId, actorId: actorId}
                bauerFoundBaerbel: gameState.specialConditions.bauerFoundBaerbel, // √úbernehme bestehenden Status
                martinTarget: null, // {targetId: targetId, actorId: actorId}
                martinSawSabine: false,
                sabineProtected: false,
                sigridTarget: null // targetId
            };

            // --- 1. Aktionen sammeln und vorbereiten ---
            gameState.nightActions.forEach(action => {
                const actor = getPlayerData(action.actor);
                if (!actor || actor.status !== 'alive') return;

                const targetPlayer = action.target ? getPlayerByName(action.target) : null;
                const targetId = targetPlayer?.id;
                const targets = action.targets ? action.targets.map(name => getPlayerByName(name)?.id).filter(id => id) : [];

                switch (action.action) {
                    case 'kill': // Werwolf
                        nightSummary.wwTarget = targetId;
                        break;
                    case 'choose_client': // Dielenschleiferin
                        nightSummary.dielenClient = targetId;
                        break;
                    case 'protect_neighbor': // Sigrid
                        if (targetId) {
                           nightSummary.protections[targetId] = 'SCHUTZSCHILD_SIGRID';
                           nightSummary.sigridTarget = targetId; // Speichern f√ºr evtl. Logik
                        }
                        break;
                    case 'protect_guest': // B√§rbel
                        if (targetId) {
                            nightSummary.protections[targetId] = 'BORDELL_BAERBEL';
                            // B√§rbel Selbstschutz-Logik
                            if (targetId === nightSummary.wwTarget && getPlayerData(targetId)?.roleKey === 'WERWOLF') {
                                actor.misc.baerbelSelfProtect = true;
                            }
                        }
                        break;
                    case 'reveal_role': // Martin
                         if (targetId) {
                            nightSummary.martinTarget = { targetId: targetId, actorId: actor.id };
                            if (getPlayerData(targetId)?.roleKey === 'Oeko_Sabine') {
                                nightSummary.martinSawSabine = true;
                                actor.misc.sawSabine = true; // Am Spieler merken f√ºr Todes-Check
                            }
                         }
                        break;
                    case 'use_potion': // Hilde
                         if (targetId && action.subAction) {
                             if (action.subAction === 'protect') nightSummary.protections[targetId] = 'KRAEUTERHEXE_HILDE';
                             else if (action.subAction === 'block_ww') nightSummary.blocks.push(targetId);
                             else if (action.subAction === 'chaos') nightSummary.chaosTargets.push(targetId);
                         }
                         break;
                    case 'ask_dead': // Norbert
                         const mediumId = action.medium ? getPlayerByName(action.medium)?.id : null;
                         if (targetId && mediumId) {
                            // Info wird direkt gegeben, hier nur f√ºr Log speichern
                            logGameEvent(`Norbert (${actor.name}) fragt Geist ${action.medium} √ºber ${action.target}`);
                         }
                         break;
                    case 'find_baerbel': // B√§uerin
                         if (targetId) {
                             nightSummary.bauerTarget = { targetId: targetId, actorId: actor.id };
                             if (getPlayerData(targetId)?.roleKey === 'BORDELL_BAERBEL') {
                                 nightSummary.bauerFoundBaerbel = true; // F√ºr diese Nacht merken
                                 gameState.specialConditions.bauerFoundBaerbel = true; // Dauerhaft merken
                                 actor.misc.bauerProtectedThisNight = true; // Schutz f√ºr diese Nacht
                             }
                         }
                         break;
                    case 'sabine_actions': // √ñko Sabine
                         if (action.protected) {
                             nightSummary.protections[actor.id] = 'Oeko_Sabine';
                             nightSummary.sabineProtected = true;
                         }
                         // Info aus Nacht 1 wird nicht hier gespeichert
                         break;
                    case 'revive': // Brunhilde
                         if (targetId) nightSummary.revives.push(targetId);
                         break;
                    case 'check_wolf': // Toni
                         if (targetId) {
                             // Info wird direkt gegeben
                             logGameEvent(`Toni (${actor.name}) pr√ºft ${action.target}`);
                         }
                         break;
                    case 'guard_village': // Wenzel
                         if (action.watches) nightSummary.wenzelWatched = true;
                         break;
                    case 'find_wiebke': // Frida
                         if (targetId) {
                             nightSummary.fridaTarget = { targetId: targetId, actorId: actor.id };
                             const targetRole = getPlayerData(targetId)?.roleDetails;
                             if (targetRole && targetRole.team === 'werwolf') {
                                 nightSummary.fridaDied = true; // Stirbt sofort
                             }
                         }
                         break;
                    case 'find_twink': // Konny
                         if (targetId) {
                             nightSummary.konnyTarget = { targetId: targetId, actorId: actor.id };
                             if (getPlayerData(targetId)?.roleKey === 'DER_TWINK') {
                                 nightSummary.twinkAbilityDeactivated = true; // Merken f√ºr diese Nacht/Tag
                                 gameState.specialConditions.twinkDeactivated = true; // Dauerhaft merken
                             }
                         }
                         break;
                    case 'spread_rumor': // K√§the
                         if (targetId && action.rumorText) {
                             nightSummary.rumors.push({ targetId: targetId, rumorText: action.rumorText });
                         }
                         break;
                    case 'link_three': // Valentin
                         if (targets.length === 3) {
                             nightSummary.linked = targets;
                             nightSummary.linkedType = 'valentin';
                         }
                         break;
                    case 'link_two': // Waltraud
                         if (targets.length === 2) {
                             nightSummary.linked = targets;
                             nightSummary.linkedType = 'waltraud';
                         }
                         break;
                    case 'infect_roll': // Iltussy
                         if (targetId && action.infected) {
                             nightSummary.infections.push({ targetId: targetId, actorId: actor.id });
                         }
                         break;
                    case 'retten_oder_ausschalten': // Tanja
                         if (action.subAction === 'retten' && targetId) {
                             nightSummary.heals.push(targetId);
                         } else if (action.subAction === 'ausschalten' && targetId) {
                             nightSummary.ausschaltenTarget = { targetId: targetId, actorId: actor.id };
                         }
                         break;
                    case 'poison': // Gertrud
                         if (targetId) {
                             nightSummary.poisons.push({ targetId: targetId, actorId: actor.id });
                         }
                         break;
                    case 'visit_and_learn': // Twink
                         if (targetId) {
                             nightSummary.twinkVisitTarget = { targetId: targetId, actorId: actor.id };
                             if (getPlayerData(targetId)?.roleKey === 'DER_GEILE_PRIESTER') {
                                 nightSummary.twinkKilledByPriest = true; // Stirbt sofort
                             }
                         }
                         break;
                    case 'hunt_twink': // Priester
                         if (targetId) {
                             nightSummary.priestTarget = { targetId: targetId, actorId: actor.id };
                             if (getPlayerData(targetId)?.roleKey === 'DER_TWINK') {
                                 actor.misc.priesterProtectedThisNight = true; // Schutz f√ºr diese Nacht
                             }
                         }
                         break;
                }
            });

            // --- 2. Effekte anwenden und Todesf√§lle ermitteln ---

            // Spieler, die diese Nacht sterben k√∂nnten und deren Schutzstatus
            let potentialDeaths = new Map(); // key: playerId, value: { causes: [], isProtectedBy: null }

            // Werwolf-Ziel hinzuf√ºgen
            if (nightSummary.wwTarget && getPlayerData(nightSummary.wwTarget)?.status === 'alive') {
                potentialDeaths.set(nightSummary.wwTarget, { causes: ['werwolf'], isProtectedBy: null });
            }
            // Tanja-Ausschalten-Ziel hinzuf√ºgen
            if (nightSummary.ausschaltenTarget?.targetId && getPlayerData(nightSummary.ausschaltenTarget.targetId)?.status === 'alive') {
                 if (!potentialDeaths.has(nightSummary.ausschaltenTarget.targetId)) {
                     potentialDeaths.set(nightSummary.ausschaltenTarget.targetId, { causes: [], isProtectedBy: null });
                 }
                 potentialDeaths.get(nightSummary.ausschaltenTarget.targetId).causes.push('tanja_ausschalten');
            }
             // Frida Tod durch WW-Ber√ºhrung
            if (nightSummary.fridaDied) {
                 const fridaPlayer = gameState.players.find(p => p.roleKey === 'FISTERIN_FRIDA' && p.status === 'alive');
                 if(fridaPlayer) {
                    if (!potentialDeaths.has(fridaPlayer.id)) {
                        potentialDeaths.set(fridaPlayer.id, { causes: [], isProtectedBy: null });
                    }
                    potentialDeaths.get(fridaPlayer.id).causes.push('frida_fehler');
                 }
            }
             // Twink Tod durch Priester
            if (nightSummary.twinkKilledByPriest) {
                 const twinkPlayer = gameState.players.find(p => p.roleKey === 'DER_TWINK' && p.status === 'alive');
                 if (twinkPlayer) {
                    if (!potentialDeaths.has(twinkPlayer.id)) {
                        potentialDeaths.set(twinkPlayer.id, { causes: [], isProtectedBy: null });
                    }
                    potentialDeaths.get(twinkPlayer.id).causes.push('twink_priester');
                 }
            }

            // Schutzmechanismen anwenden
            potentialDeaths.forEach((details, playerId) => {
                const player = getPlayerData(playerId);
                if (!player) return;

                let protectionSource = null;
                if (nightSummary.protections[playerId]) protectionSource = nightSummary.protections[playerId];
                if (nightSummary.heals.includes(playerId)) protectionSource = protectionSource ? `${protectionSource}, Tanja (Rettung)` : 'TRIP_SITTERIN_TANJA'; // Heilung sch√ºtzt auch
                if (player.misc?.baerbelSelfProtect) protectionSource = 'BORDELL_BAERBEL (Selbstschutz)'; // B√§rbel Selbstschutz
                if (player.misc?.priesterProtectedThisNight) protectionSource = 'DER_GEILE_PRIESTER (Selbstschutz)'; // Priester Selbstschutz
                if (player.misc?.bauerProtectedThisNight) protectionSource = 'BOY_BUTTER_BAEUERIN (B√§rbel gefunden)'; // B√§uerin Schutz
                if (nightSummary.wenzelWatched) protectionSource = 'WACHMANN_WENZEL'; // Wenzel Schutz

                // Hilde WW-Blockade (wirkt nur gegen WW-Angriff)
                if (details.causes.includes('werwolf')) {
                    const attackingWolves = getLivingPlayers('werwolf');
                    const activeAttackers = attackingWolves.filter(wolf => !nightSummary.blocks.includes(wolf.id));
                     if (activeAttackers.length === 0 && attackingWolves.length > 0) {
                        protectionSource = 'KRAEUTERHEXE_HILDE (Alle WW blockiert)';
                    }
                    // Einzelne blockierte W√∂lfe anzeigen
                    attackingWolves.forEach(wolf => {
                        if (nightSummary.blocks.includes(wolf.id)) {
                             wolf.misc.blockWWActive = true; // Markieren f√ºr Anzeige
                             messages.push(`${wolf.name} (Werwolf) wurde von der Hexe blockiert und konnte nicht angreifen!`);
                        }
                    });
                }

                details.isProtectedBy = protectionSource;
            });

            // Todesf√§lle basierend auf Schutz auswerten
            potentialDeaths.forEach((details, playerId) => {
                 const player = getPlayerData(playerId);
                 if (details.isProtectedBy) {
                     messages.push(`${player.name} wurde angegriffen (${details.causes.join('/')}), aber von ${ROLES[details.isProtectedBy]?.name || details.isProtectedBy} besch√ºtzt!`);
                 } else {
                     player.status = 'dead';
                     deathsThisNight.push(player);
                     messages.push(`${player.name} (${player.role}) ist gestorben! (Ursache: ${details.causes.join('/')})`);
                 }
            });

            // Gift setzen / Timer aktualisieren (nachdem Schutz gepr√ºft wurde)
            nightSummary.poisons.forEach(poisonData => {
                const targetPlayer = getPlayerData(poisonData.targetId);
                if (targetPlayer && targetPlayer.status === 'alive' && !targetPlayer.isPoisoned) {
                    targetPlayer.isPoisoned = true;
                    targetPlayer.poisonTimer = 2;
                    messages.push(`${targetPlayer.name} wurde von Gertrud vergiftet!`);
                }
            });
            gameState.players.forEach(p => { // Alle Spieler durchgehen, auch die gerade gestorbenen
                if (p.isPoisoned && p.poisonTimer > 0) {
                    p.poisonTimer--;
                    if (p.poisonTimer === 0 && p.status === 'alive') { // Nur lebende Spieler sterben jetzt daran
                        p.status = 'dead';
                        if (!deathsThisNight.some(dp => dp.id === p.id)) {
                            deathsThisNight.push(p);
                        }
                        messages.push(`${p.name} (${p.role}) ist an den Folgen des Gifts gestorben!`);
                        p.isPoisoned = false;
                    }
                }
            });

             // Infektionen durch Iltussy
            nightSummary.infections.forEach(infectionData => {
                const targetPlayer = getPlayerData(infectionData.targetId);
                if (targetPlayer && targetPlayer.status === 'alive' && targetPlayer.roleDetails.team === 'dorf') {
                    const oldRole = targetPlayer.role;
                    targetPlayer.roleDetails = ROLES.WERWOLF;
                    targetPlayer.role = ROLES.WERWOLF.name;
                    targetPlayer.roleKey = 'WERWOLF';
                    messages.push(`${targetPlayer.name} (ehemals ${oldRole}) wurde vom Iltis gebissen und ist nun ein Werwolf!`);
                    delete gameState.usedAbilities[targetPlayer.id]; // Reset F√§higkeiten
                    targetPlayer.misc = {}; // Reset Misc Data
                }
            });

            // Verlinkungen setzen (nachdem alle gestorben sind)
            if (nightSummary.linked.length >= 2) {
                 const hasKonny = nightSummary.linked.some(id => getPlayerData(id)?.roleKey === 'KONVERSIONSTHERAPIE_KONNY');
                 const hasPriester = nightSummary.linked.some(id => getPlayerData(id)?.roleKey === 'DER_GEILE_PRIESTER');
                 if (hasKonny && hasPriester) {
                     messages.push(`Versuch, Konny & Priester zu ${nightSummary.linkedType === 'valentin' ? 'verkuppeln' : 'verweben'}, fehlgeschlagen (Abneigung).`);
                 } else {
                     gameState.specialConditions.linkedPlayers = nightSummary.linked;
                     const linkedNames = nightSummary.linked.map(id => getPlayerData(id)?.name).filter(Boolean).join(', ');
                     messages.push(`${linkedNames} sind nun durch ${nightSummary.linkedType === 'valentin' ? 'Liebe' : 'Schicksal'} verbunden!`);
                 }
            }
             // Kettentod durch Verlinkung pr√ºfen
             if (gameState.specialConditions.linkedPlayers.length > 0) {
                 const linkedGroup = gameState.specialConditions.linkedPlayers.map(id => getPlayerData(id)).filter(Boolean);
                 const anyLinkedDied = linkedGroup.some(p => p.status === 'dead');
                 if (anyLinkedDied) {
                     linkedGroup.forEach(p => {
                         if (p.status === 'alive') {
                             p.status = 'dead';
                             if (!deathsThisNight.some(dp => dp.id === p.id)) {
                                 deathsThisNight.push(p);
                             }
                             messages.push(`${p.name} (${p.role}) stirbt aus Kummer/Schicksal mit!`);
                         }
                     });
                     gameState.specialConditions.linkedPlayers = []; // Band gebrochen
                 }
             }


            // Dielenschleiferin-Kunde setzen
            const clientPlayer = getPlayerData(nightSummary.dielenClient);
            if (clientPlayer && clientPlayer.status === 'alive') {
                clientPlayer.clientForDielenschleiferin = true;
            }

            // Chaos-Trank-Effekt f√ºr den Tag markieren
            nightSummary.chaosTargets.forEach(targetId => {
                const targetPlayer = getPlayerData(targetId);
                if (targetPlayer && targetPlayer.status === 'alive') {
                    targetPlayer.misc.chaostrankActive = true;
                    messages.push(`${targetPlayer.name} wurde mit einem Chaostrank belegt.`);
                }
            });

            // Ger√ºchte f√ºr den Tag speichern
            nightSummary.rumors.forEach(rumor => {
                 const targetPlayer = getPlayerData(rumor.targetId);
                 if (targetPlayer && targetPlayer.status === 'alive') {
                     targetPlayer.misc.rumor = rumor.rumorText;
                     messages.push(`√úber ${targetPlayer.name} wird ein Ger√ºcht verbreitet.`);
                 }
            });


            // --- 3. Tagesereignis ausl√∂sen? ---
            gameState.specialConditions.activeEvent = null; // Reset event
            dayEventAnnouncement.classList.add('hidden');
            if (gameState.specialConditions.eventsEnabled && gameState.day >= gameState.config.minEventDay && (gameState.day - gameState.specialConditions.lastEventDay >= gameState.config.minDaysBetweenEvents)) {
                if (Math.random() < gameState.config.eventProbability) {
                    const eventType = Math.random() < 0.5 ? 'Unwetter' : 'Pandemie';
                    gameState.specialConditions.activeEvent = { name: eventType };
                    gameState.specialConditions.lastEventDay = gameState.day;
                    logGameEvent(`Sonderereignis ausgel√∂st: ${eventType}`);
                    dayEventAnnouncement.classList.remove('hidden');
                    let eventText = "";
                    if (eventType === 'Unwetter') {
                        eventText = "Ein heftiges Unwetter zieht auf! Die heutige Diskussion wird auf 2 Minuten verk√ºrzt.";
                    } else { // Pandemie
                        const living = getLivingPlayers();
                        const maxAffected = Math.min(4, living.length);
                        const minAffected = Math.min(2, living.length);
                        const numAffected = Math.floor(Math.random() * (maxAffected - minAffected + 1)) + minAffected;
                        const affectedPlayers = living.sort(() => 0.5 - Math.random()).slice(0, numAffected);
                        gameState.specialConditions.activeEvent.affectedPlayers = affectedPlayers.map(p => p.id);
                        eventText = `Eine Pandemie grassiert! ${affectedPlayers.map(p=>p.name).join(', ')} sind infiziert und d√ºrfen heute nicht diskutieren (aber abstimmen).`;
                    }
                    dayEventDetails.textContent = eventText;
                    messages.push(`SONDEREIGNIS: ${eventText}`);
                }
            }


            // --- 4. Nachrichten und Status anzeigen ---
            dayEventsList.innerHTML = messages.filter(Boolean).map(msg => `<li>${msg}</li>`).join('');
            if (dayEventsList.innerHTML === '') {
                 dayEventsList.innerHTML = '<li>Die Nacht war bemerkenswert ereignislos.</li>';
            }

            // Todesf√§lle hervorheben
             if (deathsThisNight.length > 0) {
                 const deathLi = document.createElement('li');
                 deathLi.classList.add('font-semibold', 'text-red-400', 'mt-2', 'pt-2', 'border-t', 'border-gray-600');
                 deathLi.textContent = `Verstorben in dieser Nacht: ${deathsThisNight.map(p => `${p.name} (${p.role})`).join(', ')}`;
                 dayEventsList.appendChild(deathLi);
             }


            renderPlayerList(dayPlayerListStatus, gameState.players, false); // Alle Spieler anzeigen (lebend/tot)

            dayCounter.textContent = gameState.day;
            showScreen('screen-day-results');

            // --- 5. Spielende pr√ºfen ---
            if (checkGameOver()) return; // Spiel beenden, wenn Bedingungen erf√ºllt

            // --- 6. Wiederbelebte Spieler verarbeiten (nach Todesfeststellung & Spielende-Check) ---
            nightSummary.revives.forEach(targetId => {
                 const targetPlayer = getPlayerData(targetId);
                 if (targetPlayer && targetPlayer.status === 'dead') { // Nur tote Spieler wiederbeleben
                     targetPlayer.status = 'alive';
                     // Reset Status & F√§higkeiten
                     targetPlayer.isPoisoned = false;
                     targetPlayer.poisonTimer = 0;
                     targetPlayer.linkedTo = [];
                     targetPlayer.clientForDielenschleiferin = false;
                     targetPlayer.misc = {};
                     // Neue Rolle zuweisen (zuf√§llig aus allen *au√üer* einzigartigen/unkopierbaren?) - VEREINFACHT: Dorfbewohner
                     const oldRole = targetPlayer.role;
                     const newRoleKey = 'DORFBEWOHNER'; // TODO: Bessere Logik f√ºr neue Rolle
                     targetPlayer.roleKey = newRoleKey;
                     targetPlayer.roleDetails = ROLES[newRoleKey];
                     targetPlayer.role = ROLES[newRoleKey].name;
                     delete gameState.usedAbilities[targetPlayer.id];
                     logGameEvent(`${targetPlayer.name} (ehemals ${oldRole}) wurde von Brunhilde wiederbelebt und ist nun ein ${targetPlayer.role}.`);
                     dayEventsList.innerHTML += `<li class="text-green-400">${targetPlayer.name} (ehemals ${oldRole}) wurde wiederbelebt als ${targetPlayer.role}!</li>`;
                     // Spielerliste neu rendern, um Status zu aktualisieren
                     renderPlayerList(dayPlayerListStatus, gameState.players, false);
                 }
            });
             // Erneuter Game Over Check nach Wiederbelebung
             if (checkGameOver()) return;
        }


        function startDiscussion() {
            dayCounterVote.textContent = gameState.day;
            dayVoteRestrictions.textContent = ''; // Reset Einschr√§nkungen

            // Timer Logik
            clearInterval(discussionTimerInterval); // Alten Timer l√∂schen
            let timeRemaining = gameState.config.discussionTime;
            if (gameState.specialConditions.activeEvent?.name === 'Unwetter') {
                timeRemaining = gameState.config.unwetterTime;
            }
            dayVoteTimer.textContent = `Diskussionszeit: ${Math.floor(timeRemaining / 60)}:${(timeRemaining % 60).toString().padStart(2, '0')}`;

            discussionTimerInterval = setInterval(() => {
                timeRemaining--;
                dayVoteTimer.textContent = `Diskussionszeit: ${Math.floor(timeRemaining / 60)}:${(timeRemaining % 60).toString().padStart(2, '0')}`;
                if (timeRemaining <= 0) {
                    clearInterval(discussionTimerInterval);
                    dayVoteTimer.textContent = "Zeit abgelaufen!";
                    // Optional: Automatisch zur Abstimmung gehen
                }
            }, 1000);

            // Pandemie-Einschr√§nkungen anzeigen
            let restrictedPlayers = [];
            if (gameState.specialConditions.activeEvent?.name === 'Pandemie') {
                restrictedPlayers = gameState.specialConditions.activeEvent.affectedPlayers || [];
                const affectedNames = restrictedPlayers.map(id => getPlayerData(id)?.name).filter(name => name);
                dayVoteRestrictions.textContent = `Pandemie: ${affectedNames.join(', ')} d√ºrfen nicht diskutieren!`;
            }

            // Beatrix Button anzeigen, wenn verf√ºgbar
            const beatrix = gameState.players.find(p => p.status === 'alive' && p.roleKey === 'BLUTMAGIERIN_BEATRIX');
            const beatrixUsed = (gameState.usedAbilities[beatrix?.id] || 0) >= (ROLES.BLUTMAGIERIN_BEATRIX.uses || 1);
             if (beatrix && !beatrixUsed) {
                 beatrixInterventionDiv.classList.remove('hidden');
                 btnBeatrixIntervene.disabled = true; // Erst aktivieren, wenn Ziel gew√§hlt
                 beatrixResultSpan.textContent = '';
             } else {
                 beatrixInterventionDiv.classList.add('hidden');
             }


            renderPlayerList(dayVoteList, getLivingPlayers(), true, 'lynch');
            btnConfirmLynch.disabled = true;
            lynchSelectionInfo.textContent = 'W√§hle einen Spieler f√ºr die Lynchung aus.';
            showScreen('screen-day-vote');

            // Ger√ºchte vorlesen lassen (SL-Aufgabe)
            getLivingPlayers().forEach(p => {
                if (p.misc.rumor) {
                    const rumorLi = document.createElement('li');
                    rumorLi.classList.add('bg-yellow-900', 'border', 'border-yellow-700', 'text-yellow-300');
                    rumorLi.innerHTML = `<span class="icon icon-megaphone">üì¢</span> ${p.name} muss folgendes Ger√ºcht vorlesen: "${p.misc.rumor}"`;
                    dayVoteList.prepend(rumorLi); // Oben anzeigen
                    delete p.misc.rumor; // Nur einmal anzeigen
                }
                 if (p.misc.chaostrankActive) {
                     const chaosLi = document.createElement('li');
                     chaosLi.classList.add('bg-purple-900', 'border', 'border-purple-700', 'text-purple-300');
                     chaosLi.innerHTML = `<span class="icon icon-potion">ü§™</span> ${p.name} steht unter dem Einfluss des Chaos-Tranks! (SL: Spieler anweisen, sich auff√§llig zu verhalten)`;
                     dayVoteList.prepend(chaosLi);
                     delete p.misc.chaostrankActive; // Effekt f√ºr diesen Tag
                 }
            });
        }

        function handleBeatrixIntervention() {
             const beatrix = gameState.players.find(p => p.status === 'alive' && p.roleKey === 'BLUTMAGIERIN_BEATRIX');
             if (!beatrix || (gameState.usedAbilities[beatrix.id] || 0) >= (ROLES.BLUTMAGIERIN_BEATRIX.uses || 1) || !gameState.lynchTarget) {
                 return; // Nicht verf√ºgbar, schon genutzt oder kein Ziel gew√§hlt
             }

             const roll = Math.floor(Math.random() * 6) + 1;
             const targetPlayerName = gameState.lynchTarget;
             let message = `Beatrix wirkt ihren Zauber auf ${targetPlayerName}! W√ºrfel: ${roll}. `;
             let saved = false;

             if (roll >= 4) {
                 message += `Gerettet!`;
                 saved = true;
                 beatrixResultSpan.classList.add('text-green-400');
                 beatrixResultSpan.classList.remove('text-red-400');
             } else {
                 message += `Kein Erfolg.`;
                 saved = false;
                  beatrixResultSpan.classList.add('text-red-400');
                 beatrixResultSpan.classList.remove('text-green-400');
             }
             beatrixResultSpan.textContent = message;
             logGameEvent(message);

             // F√§higkeit als genutzt markieren
             gameState.usedAbilities[beatrix.id] = (gameState.usedAbilities[beatrix.id] || 0) + 1;
             btnBeatrixIntervene.disabled = true; // Nur einmal pro Lynchvorgang

             // Wenn gerettet, Lynch abbrechen und direkt zur n√§chsten Nacht
             if (saved) {
                 btnConfirmLynch.disabled = true; // Verhindern, dass doch gelyncht wird
                 lynchSelectionInfo.textContent = `${targetPlayerName} wurde von Beatrix gerettet!`;
                  setTimeout(() => {
                     if (checkGameOver()) return;
                     startNightPhase();
                 }, 3000);
             }
        }


        function confirmLynch() {
            clearInterval(discussionTimerInterval); // Timer stoppen
            if (!gameState.lynchTarget) return;

            const targetPlayer = getPlayerByName(gameState.lynchTarget);
            if (!targetPlayer) return;

            // Pr√ºfen ob Beatrix eingegriffen und gerettet hat
             if (beatrixResultSpan.textContent.includes("Gerettet")) {
                 logGameEvent(`Lynchversuch auf ${targetPlayer.name} durch Beatrix verhindert.`);
                 if (checkGameOver()) return;
                 startNightPhase();
                 return;
             }

            targetPlayer.status = 'dead';
            logGameEvent(`${targetPlayer.name} wird gelyncht.`);
            lynchResultText.textContent = `Das Dorf hat entschieden: ${targetPlayer.name} wird gelyncht!`;
            lynchRoleReveal.textContent = `${targetPlayer.name} war... ${targetPlayer.role}!`;

            lynchConsequences.innerHTML = ''; // Reset Konsequenzen

            // --- Kettenreaktionen durch Lynchung ---
            // Dielenschleiferin
            if (targetPlayer.clientForDielenschleiferin) {
                const dielenSchleiferin = gameState.players.find(p => p.roleKey === 'DIELENSCHLEIFERIN' && p.status === 'alive');
                if (dielenSchleiferin) {
                    dielenSchleiferin.status = 'dead';
                    lynchConsequences.innerHTML += `<li>Da ${targetPlayer.name} ihr Kunde war, stirbt auch die Dielenschleiferin (${dielenSchleiferin.name})!</li>`;
                    logGameEvent(`Dielenschleiferin ${dielenSchleiferin.name} stirbt mit Kunde ${targetPlayer.name}.`);
                }
            }

            // Verliebte / Verwobene
            if (gameState.specialConditions.linkedPlayers?.includes(targetPlayer.id)) {
                 const linkedPlayers = gameState.specialConditions.linkedPlayers.map(id => getPlayerData(id));
                 linkedPlayers.forEach(p => {
                        if (p && p.status === 'alive' && p.id !== targetPlayer.id) {
                            p.status = 'dead';
                            lynchConsequences.innerHTML += `<li>${p.name} (${p.role}) stirbt aus Kummer/Schicksal mit ${targetPlayer.name}!</li>`;
                            logGameEvent(`${p.name} stirbt wegen Verbindung zu ${targetPlayer.name}.`);
                        }
                    });
                 gameState.specialConditions.linkedPlayers = []; // Band gebrochen
            }

            // Martin/Sabine
             const martinPlayer = gameState.players.find(p => p.roleKey === 'MANSPLAINING_MARTIN' && p.status === 'alive');
             if (martinPlayer && targetPlayer.roleKey === 'Oeko_Sabine' && martinPlayer.misc.sawSabine) {
                 martinPlayer.status = 'dead';
                 lynchConsequences.innerHTML += `<li>Da √ñko Sabine stirbt, stirbt Mansplaining Martin (${martinPlayer.name}) an gebrochenem Stolz mit!</li>`;
                 logGameEvent(`Mansplaining Martin stirbt mit √ñko Sabine.`);
             }

            renderPlayerList(lynchPlayerListStatus, gameState.players, false); // Alle Spieler aktualisiert anzeigen
            showScreen('screen-lynch-result');

            // Nach Lynchung auf Spielende pr√ºfen
             if (checkGameOver()) return;

            // Reset f√ºr den n√§chsten Tag/Nacht
            gameState.lynchTarget = null;
            beatrixResultSpan.textContent = '';
        }


        // --- Spielende Logik ---
        function checkGameOver() {
            const livingPlayers = gameState.players.filter(p => p.status === 'alive');
            const livingWolves = livingPlayers.filter(p => p.roleDetails.team === 'werwolf');
            const livingDorf = livingPlayers.filter(p => p.roleDetails.team === 'dorf' || p.roleDetails.winCondition === 'dorf_wins');
            const livingWiebke = livingPlayers.find(p => p.roleKey === 'WUT_WIEBKE');

            let gameOver = false;
            let winner = null;
            let winners = [];

            // 1. Susie Sieg (Sonderfall, wird nur nach Tag 1 Lynch ausgel√∂st)
            // Wird bereits in confirmLynch() gepr√ºft

            // 2. Wiebke Sieg
            if (livingWiebke && livingPlayers.length === 1) {
                gameOver = true;
                winner = 'wiebke';
                winners = [livingWiebke];
            }

            // 3. Werwolf Sieg
            // W√∂lfe gewinnen, wenn sie gleich viele oder mehr sind als alle anderen zusammen (au√üer Wiebke)
            // ODER wenn nur noch W√∂lfe leben (und evtl. Wiebke, die dann aber nicht gewinnt)
            const livingNonWolvesNonWiebke = livingPlayers.filter(p => p.roleDetails.team !== 'werwolf' && p.roleKey !== 'WUT_WIEBKE');
            if (!gameOver && livingWolves.length > 0 && livingWolves.length >= livingNonWolvesNonWiebke.length) {
                 gameOver = true;
                 winner = 'werwolf';
                 winners = livingWolves; // Nur die W√∂lfe gewinnen
            }


            // 4. Dorfsieg
            // Dorf gewinnt, wenn alle W√∂lfe tot sind UND Wiebke nicht alleine √ºbrig ist.
            if (!gameOver && livingWolves.length === 0 && !livingWiebke) {
                gameOver = true;
                winner = 'dorf';
                winners = livingDorf; // Alle lebenden Dorfbewohner (inkl. D√∂rthe)
            }
             // Spezialfall: Nur noch D√∂rthe und Wiebke leben -> Unentschieden oder Regel? Hier: Dorf (D√∂rthe) gewinnt nicht, Wiebke gewinnt nicht -> Niemand? Oder letzter WW-Kill entscheidet? Nehmen wir an, das Spiel endet hier nicht.

            if (gameOver) {
                logGameEvent(`Spielende! Gewinner: ${winner}.`);
                endGame(winner, winners);
                return true;
            }
            return false;
        }

        function endGame(winnerTeam, winnerPlayers) {
            let message = "";
            switch (winnerTeam) {
                case 'dorf':
                    message = "Die Werw√∂lfe wurden besiegt! Das Dorf hat gewonnen!";
                    break;
                case 'werwolf':
                    message = "Die Werw√∂lfe haben die Oberhand gewonnen!";
                    break;
                case 'susie':
                     // winnerPlayers sollte hier nur Susie enthalten
                     message = `${winnerPlayers[0]?.name || 'Suizid Susie'} hat das Spiel gewonnen, indem er/sie am ersten Tag gelyncht wurde!`;
                     break;
                case 'wiebke':
                      // winnerPlayers sollte hier nur Wiebke enthalten
                     message = `${winnerPlayers[0]?.name || 'Wut Wiebke'} hat alle anderen √ºberlebt und gewinnt alleine!`;
                     break;
                default:
                    message = "Das Spiel ist vorbei!";
            }
            gameOverMessage.textContent = message;

            winnersList.innerHTML = '';
            // Zeige alle Spieler, die zum Gewinnerteam geh√∂ren und noch leben
             const winningPlayersToShow = gameState.players.filter(p => {
                 if (p.status !== 'alive') return false; // Nur lebende Spieler k√∂nnen als Gewinner angezeigt werden
                 switch (winnerTeam) {
                     case 'dorf': return p.roleDetails.team === 'dorf' || p.roleDetails.winCondition === 'dorf_wins';
                     case 'werwolf': return p.roleDetails.team === 'werwolf';
                     case 'susie': return p.roleKey === 'SUIZID_SUSIE'; // Sollte eigentlich tot sein, aber zur Anzeige
                     case 'wiebke': return p.roleKey === 'WUT_WIEBKE';
                     default: return false;
                 }
             });

             // Falls das Siegerteam keine √úberlebenden hat (z.B. alle WW tot, aber Dorf auch)
            if (winningPlayersToShow.length === 0 && winnerPlayers.length > 0) {
                 // Zeige die urspr√ºnglichen Mitglieder des Siegerteams (oder den Einzelgewinner)
                 winnerPlayers.forEach(p => {
                     const li = document.createElement('li');
                     li.textContent = `${p.name} (${p.role}) - (Verstorben)`;
                     winnersList.appendChild(li);
                 });
            } else {
                 winningPlayersToShow.forEach(p => {
                     const li = document.createElement('li');
                     li.textContent = `${p.name} (${p.role})`;
                     winnersList.appendChild(li);
                 });
            }


            showScreen('screen-game-over');
        }

        // --- Hilfsfunktionen f√ºr Rollenlogik ---
        function getNeighbors(playerId) {
            const playerIndex = gameState.players.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return [];

            const livingPlayers = getLivingPlayers();
            if (livingPlayers.length < 2) return []; // Braucht mind. 1 anderen lebenden Spieler

            const playerOrder = gameState.players.map((p, index) => ({ player: p, originalIndex: index }))
                                        .filter(item => item.player.status === 'alive');

            const livingPlayerIndex = playerOrder.findIndex(item => item.player.id === playerId);
            if (livingPlayerIndex === -1) return []; // Sollte nicht passieren

            const numLiving = playerOrder.length;
            if (numLiving < 2) return [];

            const leftIndex = (livingPlayerIndex - 1 + numLiving) % numLiving;
            const rightIndex = (livingPlayerIndex + 1) % numLiving;

            const neighbors = [];
            if (playerOrder[leftIndex]) neighbors.push(playerOrder[leftIndex].player);
            // Verhindere Duplikate, wenn nur 2 Spieler leben
            if (playerOrder[rightIndex] && playerOrder[rightIndex].player.id !== playerOrder[leftIndex]?.player.id) {
                neighbors.push(playerOrder[rightIndex].player);
            }

            return neighbors;
        }

        function getSabineTargets() {
            const wolves = getLivingPlayers('werwolf');
            const nonWolves = getLivingPlayers().filter(p => p.roleDetails.team !== 'werwolf' && p.roleKey !== 'Oeko_Sabine');
            if (wolves.length === 0) return [];

            const targetWolf = wolves[Math.floor(Math.random() * wolves.length)];
            const otherTargets = nonWolves.sort(() => 0.5 - Math.random()).slice(0, 2);

            const targets = [targetWolf, ...otherTargets];
            // Sicherstellen, dass wir nicht mehr Ziele zur√ºckgeben als Spieler vorhanden sind
            while(targets.length < 3 && nonWolves.length > targets.length -1) {
                 // Falls nicht genug nonWolves da waren, f√ºlle mit W√∂lfen auf (sollte selten sein)
                 let anotherWolf = wolves.find(w => !targets.some(t => t.id === w.id));
                 if (anotherWolf) targets.push(anotherWolf);
                 else break; // Keine weiteren Spieler
            }

            return targets.sort(() => Math.random() - 0.5); // Reihenfolge mischen
        }


        // --- Event Listener ---
        btnGoToRoleAssignment.addEventListener('click', setupRoleAssignment);
        btnStartGame.addEventListener('click', validateAndStartGame);
        btnEventsYes.addEventListener('click', () => setupEvents(true));
        btnEventsNo.addEventListener('click', () => setupEvents(false));

        btnNextAction.addEventListener('click', defaultNextActionButtonLogic); // Standard-Listener

        btnStartDiscussion.addEventListener('click', startDiscussion);
        btnConfirmLynch.addEventListener('click', confirmLynch);
        btnBeatrixIntervene.addEventListener('click', handleBeatrixIntervention);
        btnStartNextNight.addEventListener('click', () => {
             if (checkGameOver()) return; // Doppelte Pr√ºfung
             startNightPhase();
        });
        btnNewGame.addEventListener('click', () => {
            // Vollst√§ndiger Reset
            gameState = {
                players: [], playerCount: 0, currentScreen: 'screen-setup-players',
                night: 0, day: 0, currentRoleIndex: -1, rolesActingTonight: [],
                nightActions: [], lynchTarget: null, gameLog: [], usedAbilities: {},
                specialConditions: { linkedPlayers: [], twinkDeactivated: false, bauerFoundBaerbel: false, eventsEnabled: false, lastEventDay: 0, activeEvent: null },
                config: gameState.config // Konfiguration beibehalten
            };
            clearInterval(discussionTimerInterval); // Timer stoppen
            // Clear UI elements that might hold old data
            playerNameInputsContainer.innerHTML = '';
            playerRoleAssignmentContainer.innerHTML = '';
            nightPlayerList.innerHTML = '';
            dayEventsList.innerHTML = '';
            dayPlayerListStatus.innerHTML = '';
            dayVoteList.innerHTML = '';
            lynchPlayerListStatus.innerHTML = '';
            winnersList.innerHTML = '';
            // Reset error messages and special UI
            roleAssignmentError.classList.add('hidden');
            nightSpecialUI.innerHTML = '';
            selectionInfo.textContent = '';
            lynchSelectionInfo.textContent = '';
            beatrixResultSpan.textContent = '';
            beatrixInterventionDiv.classList.add('hidden');
            dayEventAnnouncement.classList.add('hidden');

            setupPlayerCountButtons();
            showScreen('screen-setup-players');
        });

        // --- Initialisierung ---
        // Wrap initialization in DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed");
            setupPlayerCountButtons();
            showScreen('screen-setup-players'); // Startbildschirm anzeigen
        });

    </script>

</body>
</html>
